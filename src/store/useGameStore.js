// src/store/useGameStore.js
import { create } from "zustand";
import itemsDatabase, { getItemById } from '../data/itemsDatabase';
import { LEVEL_CHEST_TYPES, getLevelChestTypeById } from '../data/levelChestData';
import forgeRecipes from "../data/forgeDatabase";
import { dailyShopDeals } from "../data/shopData"; // Assuming this is for example, as dailyDeals generated by store
import achievementsData from '../data/achievementsDatabase';
import { RACES, getRaceDataById } from '../config/raceData';
import { ALL_ZONES_CONFIG } from '../data/worldMapData';

// <<< ИЗ КОД1: Импорты для задач >>>
import {
    ALL_TASK_DEFINITIONS,
    TASK_TYPES,
    BONUS_REWARDS_CONFIG,
    // getTaskDescription // Если нужен здесь
} from '../data/tasksData'; // Убедись, что путь правильный

import {
    ARTIFACT_SETS,
    getArtifactById,
    MAX_ARTIFACT_LEVEL, // Not explicitly used in provided snippets but good to keep if artifactsData provides it
    BASE_SHARD_COST_PER_LEVEL, // Same as above
    ALL_ARTIFACTS_ARRAY
} from '../data/artifactsData';
import { getArtifactChestById, selectWeightedRandom as selectWeightedRewardType } from '../data/artifactChestData.js';
import { GEAR_CHESTS, getGearChestById } from '../data/gearChestData';
import { v4 as uuidv4 } from 'uuid';


const STORAGE_KEY = "gameState";
const ENERGY_REFILL_INTERVAL_MS = 30 * 60 * 1000; // 30 минут
const DEFAULT_MAX_ENERGY = 30;

// --- Конфигурация уровней достижений ---
const ACHIEVEMENT_LEVEL_XP_THRESHOLDS = { 1: 0, 2: 100, 3: 250, 4: 500, 5: 1000 /* ... и так далее */ };
export const ACHIEVEMENT_LEVEL_REWARDS = {
    2: { gold: 50, diamonds: 5 },
    3: { gold: 100, diamonds: 10 },
    4: { gold: 200, diamonds: 15 },
    5: { gold: 500, diamonds: 25 }
    /* ... и так далее */
};
const getXpNeededForLevel = (level) => ACHIEVEMENT_LEVEL_XP_THRESHOLDS[level + 1] ?? Infinity;

// --- Начальные базовые статы ---
const DEFAULT_BASE_STATS = { hp: 100, attack: 10, attackSpeed: 1.0, critChance: 5, doubleStrikeChance: 0, speed: 5, range: 3, skin: 'default', defense: 0, hpRegen: 0, evasion: 0, maxMana: 0, elementalDmgPercent: 0, goldFind: 0, luck: 0, bossDmg: 0, shardFind: 0, bonusProjectiles: 0, atkPercentBonus: 0, moveSpeedPercentBonus: 0 };

// <<<--- КОНСТАНТЫ ИЗ КОД1 ДЛЯ ЗАДАЧ (и КОД2) ---<<<
const REFRESH_HOUR_UTC = 2; // Общий час UTC для сбросов (магазин, попытки рун и т.д.)
const DAILY_TASKS_REFRESH_HOUR_UTC = REFRESH_HOUR_UTC; // 2
const WEEKLY_TASKS_REFRESH_DAY_UTC = 1; // Понедельник (0=Воскресенье, 1=Понедельник, ..., 6=Суббота)
const WEEKLY_TASKS_REFRESH_HOUR_UTC = REFRESH_HOUR_UTC; // 2
const MONTHLY_TASKS_REFRESH_DAY_OF_MONTH_UTC = 1; // 1-е число месяца
const MONTHLY_TASKS_REFRESH_HOUR_UTC = REFRESH_HOUR_UTC; // 2
const RUNE_ATTEMPTS_REFRESH_HOUR_UTC = REFRESH_HOUR_UTC; // 2 (из КОД2, совпадает)

const INITIAL_CHAPTER_ID = 1;

const createItemInstance = (itemTemplate) => {
    if (!itemTemplate) {
        console.warn("Attempted to create instance from null/undefined template");
        return null;
    }
    return {
        ...itemTemplate,
        uid: uuidv4(),
        currentLevel: 0, // Assuming items can be leveled, if not, remove
    };
};

const getDefaultEquippedSet = () => {
    const defaultSet = {
        weapon: null, amulet: null, ring: null, helmet: null, armor: null, boots: null,
    };
    const types = Object.keys(defaultSet);

    types.forEach(type => {
        const commonItemTemplate = itemsDatabase.find(
            item => item.type === type && item.rarity === 'Common'
        );
        defaultSet[type] = createItemInstance(commonItemTemplate);
    });

    const missing = types.filter(type => defaultSet[type] === null);
    if (missing.length > 0) {
        console.warn(`Could not find default Common items for types: ${missing.join(', ')}`);
    }
    return defaultSet;
};


// --- Функция Загрузки состояния из localStorage (ОБЪЕДИНЕНА С КОД1) ---
const loadFromLocalStorage = () => {
    try {
        const saved = localStorage.getItem(STORAGE_KEY);

        // <<< ИЗ КОД1: Дефолтное состояние для задач >>>
        const defaultStateForTasks = {
            dailyTaskProgress: {}, dailyTaskBarXp: 0, dailyBonusClaimed: false, lastDailyReset: null,
            dailyLoginToday: false, killsToday: 0, levelsCompletedToday: 0, gearUpgradedToday: 0, chestsOpenedToday: 0,
            // Specific login day counters for weekly/monthly will need careful management if 'login' event should update them for uniqueness
            lastSeenLoginDateForWeekly: null, // Example helper for unique weekly logins
            lastSeenLoginDateForMonthly: null, // Example helper for unique monthly logins
            weeklyTaskProgress: {}, weeklyTaskBarXp: 0, weeklyBonusClaimed: false, lastWeeklyReset: null,
            weeklyLoginDays: 0, // Counts unique login days in the current week
            killsThisWeek: 0, levelsCompletedThisWeek: 0, gearUpgradedThisWeek: 0, chestsOpenedThisWeek: 0,
            monthlyTaskProgress: {}, monthlyTaskBarXp: 0, monthlyBonusClaimed: false, lastMonthlyReset: null,
            monthlyLoginDays: 0, // Counts unique login days in the current month
            killsThisMonth: 0, levelsCompletedThisMonth: 0, gearUpgradedThisMonth: 0, chestsOpenedThisMonth: 0,
        };

        if (!saved) {
            console.log("No saved state found. Initializing with default Common gear and tasks.");
            return {
                equipped: getDefaultEquippedSet(),
                collectedArtifacts: new Set(),
                gold: 100000, // Generous starting gold for testing
                diamonds: 10000, // Generous starting diamonds for testing
                username: null,
                powerLevel: 0,
                playerBaseStats: { ...DEFAULT_BASE_STATS },
                playerHp: DEFAULT_BASE_STATS.hp,
                playerRace: null,
                inventory: [],
                energyMax: DEFAULT_MAX_ENERGY,
                energyCurrent: DEFAULT_MAX_ENERGY,
                lastEnergyRefillTimestamp: Date.now(),
                dailyShopPurchases: {},
                achievementsStatus: {},
                totalGoldCollected: 0,
                totalKills: 0,
                booleanFlags: {},
                levelsCompleted: {},
                achievementLevel: 1,
                achievementXp: 0,
                artifactLevels: {},
                artifactChestPity: {},
                gearKeys: 0, // Assuming this is a currency for gear chests
                totalArtifactChestsOpened: 0,
                gearChestPity: {},
                totalGearChestsOpened: 0,
                dailyDeals: [], // Populated by generateDailyDeals
                dailyDealsLastGenerated: null,
                lastOpenedChestInfo: null, // For displaying rewards from last opened chest
                lastChestRewards: null,    // For displaying rewards from last opened chest
                treasureChestAttempts: 3,
                treasureChestLastReset: null,
                activeDebuffs: [],
                completedZones: {},
                isAffectedByWeakeningAura: false,
                userPhotoUrl: null,
                currentChapterId: INITIAL_CHAPTER_ID,
                // <<< ИЗ КОД1: Добавляем дефолты для заданий >>>
                ...defaultStateForTasks,
            };
        }

        let parsed = JSON.parse(saved);
        console.log("Saved state found. Processing...");

        // Migration for playerBaseStats (if old structure exists)
        if (parsed && parsed.playerBaseStats && (parsed.playerBaseStats.defense !== undefined || parsed.playerBaseStats.health !== undefined)) {
            console.log("Миграция старых playerBaseStats...");
            let updatedStats = { ...parsed.playerBaseStats };
            delete updatedStats.defense; // Assuming defense is now calculated or handled differently
            if (updatedStats.health !== undefined) { updatedStats.hp = updatedStats.health; delete updatedStats.health; }
            Object.keys(DEFAULT_BASE_STATS).forEach(key => { updatedStats[key] = updatedStats[key] ?? DEFAULT_BASE_STATS[key]; });
            parsed.playerBaseStats = updatedStats;
            console.log("Миграция playerBaseStats завершена.");
        }

        // Инициализация полей по умолчанию, если они отсутствуют В ЗАГРУЖЕННОМ СОСТОЯНИИ
        const defaultFullStateForNewKeys = { // Combine all defaults for easy check
            equipped: getDefaultEquippedSet(), collectedArtifacts: new Set(), gold: 0, diamonds: 0, username: null, powerLevel: 0,
            playerBaseStats: { ...DEFAULT_BASE_STATS }, playerHp: DEFAULT_BASE_STATS.hp, playerRace: null, inventory: [],
            energyMax: DEFAULT_MAX_ENERGY, energyCurrent: DEFAULT_MAX_ENERGY, lastEnergyRefillTimestamp: Date.now(),
            dailyShopPurchases: {}, achievementsStatus: {}, totalGoldCollected: 0, totalKills: 0, booleanFlags: {},
            levelsCompleted: {}, achievementLevel: 1, achievementXp: 0, artifactLevels: {}, artifactChestPity: {},
            gearKeys: 0, totalArtifactChestsOpened: 0, gearChestPity: {}, totalGearChestsOpened: 0, dailyDeals: [],
            dailyDealsLastGenerated: null, lastOpenedChestInfo: null, lastChestRewards: null, treasureChestAttempts: 3,
            treasureChestLastReset: null, activeDebuffs: [], isAffectedByWeakeningAura: false, completedZones: {},
            userPhotoUrl: null, currentChapterId: INITIAL_CHAPTER_ID,
            ...defaultStateForTasks // Add task defaults here
        };

        for (const key in defaultFullStateForNewKeys) {
            if (parsed[key] === undefined) {
                if (key === 'collectedArtifacts') {
                     parsed[key] = new Set(); // Ensure Set is properly initialized
                } else if (key === 'equipped' && defaultFullStateForNewKeys[key] === null) { // Should be getDefaultEquippedSet()
                    parsed[key] = getDefaultEquippedSet();
                }
                else {
                    parsed[key] = defaultFullStateForNewKeys[key];
                }
            }
        }
        
        // Ensure equipped is valid or reset
        const savedEquipped = parsed.equipped;
        const isSavedEquippedInvalid = !savedEquipped || typeof savedEquipped !== 'object' || Object.keys(savedEquipped).length !== 6 || Object.values(savedEquipped).some(v => v === undefined);

        if (isSavedEquippedInvalid) {
            console.warn("Saved 'equipped' state is missing, invalid, or has undefined slots. Initializing with default Common set.");
            parsed.equipped = getDefaultEquippedSet();
        } else {
            // Further check: ensure no slot in equipped is undefined
            let needsFix = false;
            for (const slot in parsed.equipped) {
                if (parsed.equipped[slot] === undefined) {
                    needsFix = true;
                    break;
                }
            }
            if (needsFix) {
                 console.warn("Some slots in 'equipped' were undefined. Resetting to default Common set.");
                 parsed.equipped = getDefaultEquippedSet();
            }
        }


        if (parsed.collectedArtifacts && !(parsed.collectedArtifacts instanceof Set)) {
            try {
                parsed.collectedArtifacts = new Set(parsed.collectedArtifacts);
            } catch (e) {
                console.error("Failed to reconstruct Set for collectedArtifacts, resetting.", e);
                parsed.collectedArtifacts = new Set();
            }
        }
        // Ensure other new fields from defaultStateForTasks are present
        for (const key in defaultStateForTasks) {
            if (parsed[key] === undefined) {
                parsed[key] = defaultStateForTasks[key];
            }
        }

        return parsed;

    } catch (error) {
        console.error("Critical error during loadFromLocalStorage:", error);
        localStorage.removeItem(STORAGE_KEY); // Clear corrupted storage
        // Return a fully default state on critical error
        const defaultOnErrorState = {
            equipped: getDefaultEquippedSet(), collectedArtifacts: new Set(), gold: 0, diamonds: 0, username: null, powerLevel: 0,
            playerBaseStats: { ...DEFAULT_BASE_STATS }, playerHp: DEFAULT_BASE_STATS.hp, playerRace: null, inventory: [],
            energyMax: DEFAULT_MAX_ENERGY, energyCurrent: DEFAULT_MAX_ENERGY, lastEnergyRefillTimestamp: Date.now(),
            dailyShopPurchases: {}, achievementsStatus: {}, totalGoldCollected: 0, totalKills: 0, booleanFlags: {},
            levelsCompleted: {}, achievementLevel: 1, achievementXp: 0, artifactLevels: {}, artifactChestPity: {},
            gearKeys: 0, totalArtifactChestsOpened: 0, gearChestPity: {}, totalGearChestsOpened: 0, dailyDeals: [],
            dailyDealsLastGenerated: null, lastOpenedChestInfo: null, lastChestRewards: null, treasureChestAttempts: 3,
            treasureChestLastReset: null, activeDebuffs: [], isAffectedByWeakeningAura: false, completedZones: {},
            userPhotoUrl: null, currentChapterId: INITIAL_CHAPTER_ID,
            ...defaultStateForTasks, // <<< ИЗ КОД1: Добавляем дефолты для заданий при ошибке >>>
        };
        return defaultOnErrorState;
    }
};


const RARITY_WEIGHTS = { // For artifact selection within a set
    common: 100,
    uncommon: 50,
    rare: 25,
    legendary: 8, // Mythic was in code1, ensure itemsDatabase uses this casing
    mythic: 2
};

function weightedRandom(itemsWithWeight) {
    if (!itemsWithWeight || itemsWithWeight.length === 0) {
        console.error('[weightedRandom] Получен пустой или невалидный массив!');
        return null;
    }
    let totalWeight = itemsWithWeight.reduce((sum, entry) => {
        const weight = entry?.weight ?? 0;
        if (typeof weight !== 'number' || isNaN(weight) || weight < 0) {
            console.warn('[weightedRandom] Невалидный вес у элемента:', entry, 'Используем 0.');
            return sum;
        }
        return sum + weight;
    }, 0);

    if (totalWeight <= 0) {
        console.warn('[weightedRandom] Общий вес <= 0. Возврат случайного элемента (если есть).');
        return itemsWithWeight.length > 0 ? itemsWithWeight[Math.floor(Math.random() * itemsWithWeight.length)].item : null;
    }
    let random = Math.random() * totalWeight;
    for (let i = 0; i < itemsWithWeight.length; i++) {
        const currentWeight = itemsWithWeight[i]?.weight ?? 0;
        if (random < currentWeight) {
            return itemsWithWeight[i]?.item;
        }
        random -= currentWeight;
    }
    console.error('[weightedRandom] Цикл завершился без выбора! Этого не должно происходить при totalWeight > 0. Возврат последнего элемента.');
    return itemsWithWeight.length > 0 ? itemsWithWeight[itemsWithWeight.length - 1]?.item : null;
}

const DAILY_DEAL_RARITY_WEIGHTS = { // For items appearing in daily deals
    common: 70,
    uncommon: 25,
    rare: 5,
};

const _selectWeightedArtifactIdFromSet_ByRarity = (setId) => {
    const targetSet = ARTIFACT_SETS.find(s => s.id === setId);
    if (!targetSet || !targetSet.artifacts || targetSet.artifacts.length === 0) {
        console.error(`[SelectWeightedArtifact] Сет ${setId} не найден или пуст!`);
        return null;
    }
    const weightedArtifactPool = targetSet.artifacts.map(artifact => ({
        id: artifact.id,
        // Ensure rarity string matches keys in RARITY_WEIGHTS (e.g., lowercase)
        weight: RARITY_WEIGHTS[artifact.rarity.toLowerCase()] || 1
    }));
    const totalWeight = weightedArtifactPool.reduce((sum, item) => sum + item.weight, 0);
    if (totalWeight <= 0) {
        console.warn(`[SelectWeightedArtifact] Все веса для сета ${setId} нулевые, выбор случайный.`);
        const randomIndex = Math.floor(Math.random() * weightedArtifactPool.length);
        return weightedArtifactPool[randomIndex].id;
    }
    let randomValue = Math.random() * totalWeight;
    for (const item of weightedArtifactPool) {
        if (randomValue < item.weight) {
            return item.id;
        }
        randomValue -= item.weight;
    }
    console.warn(`[SelectWeightedArtifact] Ошибка взвешенного выбора для сета ${setId}, возврат последнего элемента.`);
    return weightedArtifactPool[weightedArtifactPool.length - 1].id;
};

const _rollWeightedRarity_Gear = (rarityChances) => { // For gear drops
    if (!rarityChances || Object.keys(rarityChances).length === 0) {
        console.error("[RollRarityGear] Объект шансов пуст!");
        return 'Common'; // Default to Common
    }
    const totalWeight = Object.values(rarityChances).reduce((sum, chance) => sum + (chance || 0), 0);
    if (totalWeight <= 0) {
        console.warn("[RollRarityGear] Сумма шансов равна нулю, возвращаем первую редкость.");
        return Object.keys(rarityChances)[0] || 'Common';
    }
    const randomValue = Math.random() * totalWeight;
    let cumulativeWeight = 0;
    for (const [rarity, chance] of Object.entries(rarityChances)) {
        cumulativeWeight += (chance || 0);
        if (randomValue < cumulativeWeight) {
            return rarity; // Returns the key (string like "Common", "Rare")
        }
    }
    console.warn("[RollRarityGear] Не удалось выбрать редкость по весу, возврат последнего.");
    return Object.keys(rarityChances).pop() || 'Common';
};

const _selectRandomGearItemByRarity_Gear = (targetRarity) => { // targetRarity is a string
    const possibleItems = itemsDatabase.filter(item => item.rarity === targetRarity);
    if (possibleItems.length === 0) {
        console.error(`[SelectGearByRarity] Нет предметов снаряжения с редкостью ${targetRarity} в itemsDatabase! Попытка найти Common.`);
        const commonItems = itemsDatabase.filter(item => item.rarity === 'Common');
        if (commonItems.length > 0) {
            const randomIndex = Math.floor(Math.random() * commonItems.length);
            return { ...commonItems[randomIndex] }; // Return a copy
        }
        console.error(`[SelectGearByRarity] Нет даже Common предметов! Возврат null.`);
        return null;
    }
    const randomIndex = Math.floor(Math.random() * possibleItems.length);
    return { ...possibleItems[randomIndex] }; // Return a copy
};

const savedState = loadFromLocalStorage();


const useGameStore = create((set, get) => ({
    // ================== Состояние (State) - Объединенное ==================
    gold: savedState.gold,
    diamonds: savedState.diamonds,
    username: savedState.username,
    userPhotoUrl: savedState.userPhotoUrl,
    powerLevel: savedState.powerLevel,
    energyMax: savedState.energyMax,
    energyCurrent: savedState.energyCurrent,
    lastEnergyRefillTimestamp: savedState.lastEnergyRefillTimestamp,
    lastOpenedLevelChestRewards: null, // Transient for UI popup
    levelChestStates: savedState.levelChestStates || {}, // Tracks opened status of specific level chests
    currentLevelRewards: { gold: 0, diamonds: 0, items: [] }, // Transient for level completion summary
    currentChapterId: savedState.currentChapterId,
    completedZones: savedState.completedZones,
    hasClaimableRewardsIndicator: false, // For achievements, tasks etc.
    playerHp: savedState.playerHp,
    playerRace: savedState.playerRace,
    playerBaseStats: savedState.playerBaseStats,
    inventory: savedState.inventory,
    equipped: savedState.equipped,
    collectedArtifacts: savedState.collectedArtifacts, // Should be a Set
    artifactLevels: savedState.artifactLevels,
    dailyShopPurchases: savedState.dailyShopPurchases,
    achievementsStatus: savedState.achievementsStatus,
    totalGoldCollected: savedState.totalGoldCollected,
    totalKills: savedState.totalKills,
    booleanFlags: savedState.booleanFlags,
    levelsCompleted: savedState.levelsCompleted,
    achievementLevel: savedState.achievementLevel,
    achievementXp: savedState.achievementXp,
    artifactChestPity: savedState.artifactChestPity,
    gearKeys: savedState.gearKeys,
    totalArtifactChestsOpened: savedState.totalArtifactChestsOpened,
    gearChestPity: savedState.gearChestPity,
    totalGearChestsOpened: savedState.totalGearChestsOpened,
    lastOpenedChestInfo: savedState.lastOpenedChestInfo, // For modal after opening gacha chests
    lastChestRewards: savedState.lastChestRewards,      // For modal after opening gacha chests
    dailyDeals: savedState.dailyDeals,
    dailyDealsLastGenerated: savedState.dailyDealsLastGenerated,
    isFullScreenMapActive: false,
    activeDebuffs: savedState.activeDebuffs,
    isScreenTransitioning: false,
    transitionAction: null, // 'closing' or 'opening'
    onTransitionCloseCompleteCallback: null,
    onTransitionOpenCompleteCallback: null,
    treasureChestAttempts: savedState.treasureChestAttempts,
    treasureChestLastReset: savedState.treasureChestLastReset,
    isAffectedByWeakeningAura: savedState.isAffectedByWeakeningAura,

    // <<< ИЗ КОД1: Состояния для задач >>>
    // Daily Tasks
    dailyTaskProgress: savedState.dailyTaskProgress,
    dailyTaskBarXp: savedState.dailyTaskBarXp,
    dailyBonusClaimed: savedState.dailyBonusClaimed,
    lastDailyReset: savedState.lastDailyReset,
    dailyLoginToday: savedState.dailyLoginToday, // Tracks if a login event occurred today for the daily task
    killsToday: savedState.killsToday,
    levelsCompletedToday: savedState.levelsCompletedToday,
    gearUpgradedToday: savedState.gearUpgradedToday,
    chestsOpenedToday: savedState.chestsOpenedToday,
    lastSeenLoginDateForWeekly: savedState.lastSeenLoginDateForWeekly,
    lastSeenLoginDateForMonthly: savedState.lastSeenLoginDateForMonthly,


    // Weekly Tasks
    weeklyTaskProgress: savedState.weeklyTaskProgress,
    weeklyTaskBarXp: savedState.weeklyTaskBarXp,
    weeklyBonusClaimed: savedState.weeklyBonusClaimed,
    lastWeeklyReset: savedState.lastWeeklyReset,
    weeklyLoginDays: savedState.weeklyLoginDays, // Counts unique login days this week
    killsThisWeek: savedState.killsThisWeek,
    levelsCompletedThisWeek: savedState.levelsCompletedThisWeek,
    gearUpgradedThisWeek: savedState.gearUpgradedThisWeek,
    chestsOpenedThisWeek: savedState.chestsOpenedThisWeek,

    // Monthly Tasks
    monthlyTaskProgress: savedState.monthlyTaskProgress,
    monthlyTaskBarXp: savedState.monthlyTaskBarXp,
    monthlyBonusClaimed: savedState.monthlyBonusClaimed,
    lastMonthlyReset: savedState.lastMonthlyReset,
    monthlyLoginDays: savedState.monthlyLoginDays, // Counts unique login days this month
    killsThisMonth: savedState.killsThisMonth,
    levelsCompletedThisMonth: savedState.levelsCompletedThisMonth,
    gearUpgradedThisMonth: savedState.gearUpgradedThisMonth,
    chestsOpenedThisMonth: savedState.chestsOpenedThisMonth,
    // <<< КОНЕЦ СОСТОЯНИЙ ИЗ КОД1 >>>

    // ================== Селекторы (Computed/Getters) ==================
    computedStats: () => { // Unchanged from code2, ensure it's complete
        const state = get();
        const now = Date.now();
        const currentActiveDebuffs = (state.activeDebuffs || []).filter(debuff => now < debuff.endTime);
        let totalWeakenDamageReductionPercent = 0;
        let totalWeakenMaxHpReductionPercent = 0;
        let totalOtherDamageReductionPercent = 0;
        let totalOtherMaxHpReductionPercent = 0;

        currentActiveDebuffs.forEach(debuff => {
            if (debuff.type === 'weaken') {
                totalWeakenDamageReductionPercent += (debuff.strength || 0);
                totalWeakenMaxHpReductionPercent += (debuff.strength || 0);
            } else {
                if (debuff.hasOwnProperty('damageReductionPercent')) {
                    totalOtherDamageReductionPercent += (debuff.damageReductionPercent || 0);
                }
                if (debuff.hasOwnProperty('maxHpReductionPercent')) {
                    totalOtherMaxHpReductionPercent += (debuff.maxHpReductionPercent || 0);
                }
            }
        });

        totalWeakenDamageReductionPercent = Math.min(totalWeakenDamageReductionPercent, 80); // Cap at 80%
        totalWeakenMaxHpReductionPercent = Math.min(totalWeakenMaxHpReductionPercent, 80); // Cap at 80%
        totalOtherDamageReductionPercent = Math.min(totalOtherDamageReductionPercent, 80); // Cap at 80%
        totalOtherMaxHpReductionPercent = Math.min(totalOtherMaxHpReductionPercent, 80); // Cap at 80%

        let finalStats = { ...DEFAULT_BASE_STATS, ...(state.playerBaseStats || {}) };
        let totalGearAttackSpeedPercentBonus = 0; // For attack speed which is often multiplicative on base

        // Equipment bonuses
        for (const slot in state.equipped) {
            const item = state.equipped[slot];
            if (item) { // Check if item exists and is not null
                finalStats.hp = (finalStats.hp || 0) + (item.hpBonus || 0);
                finalStats.attack = (finalStats.attack || 0) + (item.attackBonus || 0);
                totalGearAttackSpeedPercentBonus += item.attackSpeedBonus || 0; // Sum percentage bonuses
                finalStats.critChance = (finalStats.critChance || 0) + (item.critChanceBonus || 0);
                finalStats.doubleStrikeChance = (finalStats.doubleStrikeChance || 0) + (item.doubleStrikeChanceBonus || 0);
                finalStats.speed = (finalStats.speed || 0) + (item.speedBonus || 0); // Flat speed from gear
                finalStats.range = (finalStats.range || 0) + (item.rangeBonus || 0);
                finalStats.defense = (finalStats.defense || 0) + (item.defenseBonus || 0);
                finalStats.luck = (finalStats.luck || 0) + (item.luckBonus || 0);
                finalStats.hpRegen = (finalStats.hpRegen || 0) + (item.hpRegenBonus || 0);
                finalStats.evasion = (finalStats.evasion || 0) + (item.evasionBonus || 0);
                finalStats.maxMana = (finalStats.maxMana || 0) + (item.maxManaBonus || 0);
                finalStats.elementalDmgPercent = (finalStats.elementalDmgPercent || 0) + (item.elementalDmgPercentBonus || 0);
                finalStats.goldFind = (finalStats.goldFind || 0) + (item.goldFindBonus || 0);
                finalStats.bossDmg = (finalStats.bossDmg || 0) + (item.bossDmgBonus || 0);
                finalStats.shardFind = (finalStats.shardFind || 0) + (item.shardFindBonus || 0);
                finalStats.atkPercentBonus = (finalStats.atkPercentBonus || 0) + (item.atkPercentBonus || 0); // Sum percentage bonuses
                finalStats.moveSpeedPercentBonus = (finalStats.moveSpeedPercentBonus || 0) + (item.moveSpeedPercentBonus || 0); // Sum percentage bonuses
                finalStats.bonusProjectiles = (finalStats.bonusProjectiles || 0) + (item.bonusProjectiles || 0);
            }
        }

        // Artifact bonuses (flat and per level)
        const { artifactLevels, collectedArtifacts } = state;
        let totalArtifactHp = 0, totalArtifactAttack = 0, totalArtifactDefense = 0, totalArtifactHpRegen = 0,
            totalArtifactAttackSpeed = 0, totalArtifactEvasion = 0, totalArtifactMoveSpeedBonus = 0, /* % */
            totalArtifactAtkPercentBonus = 0, /* % */ totalArtifactMaxMana = 0, totalArtifactElementalDmgPercent = 0, /* % */
            totalArtifactCritChance = 0, totalArtifactDoubleStrikeChance = 0, totalArtifactGoldFind = 0, /* % */
            totalArtifactLuck = 0, /* % */ totalArtifactBossDmg = 0, /* % */ totalArtifactShardFind = 0, /* % */ totalArtifactBonusProjectiles = 0;

        for (const artifactId in artifactLevels) {
            if (collectedArtifacts.has(artifactId)) {
                const artifactData = getArtifactById(artifactId);
                const artifactInfo = artifactLevels[artifactId];
                if (artifactData && artifactInfo) {
                    const level = artifactInfo.level;
                    if (level <= 0) continue; // Only active, leveled artifacts contribute

                    // Base stats (applied once if level > 0)
                    if (artifactData.baseStats) {
                        for (const [statName, baseValue] of Object.entries(artifactData.baseStats)) {
                            switch (statName) {
                                case "hp": totalArtifactHp += baseValue; break;
                                case "attack": totalArtifactAttack += baseValue; break;
                                case "defense": totalArtifactDefense += baseValue; break;
                                case "hpRegen": totalArtifactHpRegen += baseValue; break;
                                case "attackSpeed": totalArtifactAttackSpeed += baseValue; break; // Assuming %
                                case "evasion": totalArtifactEvasion += baseValue; break; // Assuming %
                                case "moveSpeedPercentBonus": totalArtifactMoveSpeedBonus += baseValue; break;
                                case "atkPercentBonus": totalArtifactAtkPercentBonus += baseValue; break;
                                case "maxMana": totalArtifactMaxMana += baseValue; break;
                                case "elementalDmgPercent": totalArtifactElementalDmgPercent += baseValue; break;
                                case "critChance": totalArtifactCritChance += baseValue; break;
                                case "doubleStrikeChance": totalArtifactDoubleStrikeChance += baseValue; break;
                                case "goldFind": totalArtifactGoldFind += baseValue; break;
                                case "luck": totalArtifactLuck += baseValue; break;
                                case "bossDmg": totalArtifactBossDmg += baseValue; break;
                                case "shardFind": totalArtifactShardFind += baseValue; break;
                                case "bonusProjectiles": totalArtifactBonusProjectiles += baseValue; break;
                                default: console.warn(`[WARN] Неизвестный БАЗОВЫЙ стат артефакта '${artifactId}': ${statName}`); break;
                            }
                        }
                    }
                    // Per-level stats
                    if (artifactData.levelStats) {
                        for (const [statName, levelValue] of Object.entries(artifactData.levelStats)) {
                            const bonus = levelValue * level;
                            if (bonus === 0 && levelValue !==0) continue; // Only add if there's a change
                             switch (statName) {
                                case "hp": totalArtifactHp += bonus; break;
                                case "attack": totalArtifactAttack += bonus; break;
                                case "defense": totalArtifactDefense += bonus; break;
                                case "hpRegen": totalArtifactHpRegen += bonus; break;
                                case "attackSpeed": totalArtifactAttackSpeed += bonus; break;
                                case "evasion": totalArtifactEvasion += bonus; break;
                                case "moveSpeedPercentBonus": totalArtifactMoveSpeedBonus += bonus; break;
                                case "atkPercentBonus": totalArtifactAtkPercentBonus += bonus; break;
                                case "maxMana": totalArtifactMaxMana += bonus; break;
                                case "elementalDmgPercent": totalArtifactElementalDmgPercent += bonus; break;
                                case "critChance": totalArtifactCritChance += bonus; break;
                                case "doubleStrikeChance": totalArtifactDoubleStrikeChance += bonus; break;
                                case "goldFind": totalArtifactGoldFind += bonus; break;
                                case "luck": totalArtifactLuck += bonus; break;
                                case "bossDmg": totalArtifactBossDmg += bonus; break;
                                case "shardFind": totalArtifactShardFind += bonus; break;
                                case "bonusProjectiles": totalArtifactBonusProjectiles += bonus; break;
                                default: console.warn(`[WARN] Неизвестный стат УРОВНЯ артефакта '${artifactId}': ${statName}`); break;
                            }
                        }
                    }
                } else {
                    console.warn(`[WARN] Не найдены данные или информация об уровне для артефакта ID: ${artifactId}`);
                }
            }
        }
        // Apply summed artifact bonuses
        finalStats.hp += totalArtifactHp;
        finalStats.attack += totalArtifactAttack;
        finalStats.defense += totalArtifactDefense;
        finalStats.hpRegen += totalArtifactHpRegen;
        totalGearAttackSpeedPercentBonus += totalArtifactAttackSpeed; // Add artifact AttackSpeed % to gear's
        finalStats.critChance += totalArtifactCritChance;
        finalStats.doubleStrikeChance += totalArtifactDoubleStrikeChance;
        finalStats.evasion += totalArtifactEvasion;
        finalStats.moveSpeedPercentBonus = (finalStats.moveSpeedPercentBonus || 0) + totalArtifactMoveSpeedBonus;
        finalStats.atkPercentBonus = (finalStats.atkPercentBonus || 0) + totalArtifactAtkPercentBonus;
        finalStats.maxMana += totalArtifactMaxMana;
        finalStats.elementalDmgPercent += totalArtifactElementalDmgPercent;
        finalStats.goldFind += totalArtifactGoldFind;
        finalStats.luck += totalArtifactLuck;
        finalStats.bossDmg += totalArtifactBossDmg;
        finalStats.shardFind += totalArtifactShardFind;
        finalStats.bonusProjectiles += totalArtifactBonusProjectiles;

        // Artifact Set Bonuses
        ARTIFACT_SETS.forEach(set => {
            const activeOwnedInSet = set.artifacts.filter(artifact => {
                const stateInfo = artifactLevels[artifact.id];
                return collectedArtifacts.has(artifact.id) && stateInfo && stateInfo.level > 0;
            }).length;

            set.bonuses.forEach(bonus => {
                const match = bonus.condition.match(/\[\s*Собрано\s*(\d+)\s*\]/i);
                const requiredCount = match ? parseInt(match[1], 10) : 0;
                if (requiredCount > 0 && activeOwnedInSet >= requiredCount) {
                    const desc = bonus.description.toLowerCase();
                    const valueMatch = desc.match(/([+-]?\d+(\.\d+)?)/); // Extracts numbers like +5, -10.5, 20
                    const value = valueMatch ? parseFloat(valueMatch[1]) : 0;
                    let applied = false;

                    // This part needs to be robust to various phrasing
                    if (desc.includes('макс. hp') || (desc.includes('hp') && !desc.includes('регенерация'))) {
                        if (desc.includes('%')) finalStats.hp *= (1 + value / 100); else finalStats.hp += value;
                        applied = true;
                    } else if (desc.includes('сила атаки') || desc.includes('урон') || desc.includes('атак')) {
                        if (desc.includes('%')) finalStats.atkPercentBonus = (finalStats.atkPercentBonus || 0) + value; else finalStats.attack += value;
                        applied = true;
                    } else if (desc.includes('скорость атаки')) { // Expects % bonus for attack speed from sets
                        if (desc.includes('%')) totalGearAttackSpeedPercentBonus += value; applied = true;
                    } else if (desc.includes('регенерация hp')) {
                        finalStats.hpRegen = (finalStats.hpRegen || 0) + value; applied = true;
                    } else if (desc.includes('шанс двойного удара') || desc.includes('двойной удар')) {
                        finalStats.doubleStrikeChance = (finalStats.doubleStrikeChance || 0) + value; applied = true;
                    } else if (desc.includes('шанс найти золото') || desc.includes('поиск золота')) {
                        finalStats.goldFind = (finalStats.goldFind || 0) + value; applied = true;
                    } else if (desc.includes('шанс найти осколки') || desc.includes('поиск осколков')) {
                        finalStats.shardFind = (finalStats.shardFind || 0) + value; applied = true;
                    } else if (desc.includes('шанс крит. удара') || desc.includes('крит. шанс')) {
                        finalStats.critChance = (finalStats.critChance || 0) + value; applied = true;
                    } else if (desc.includes('защита')) {
                        finalStats.defense = (finalStats.defense || 0) + value; applied = true;
                    } else if (desc.includes('удача')) {
                        finalStats.luck = (finalStats.luck || 0) + value; applied = true;
                    } else if (desc.includes('урон боссам')) {
                        finalStats.bossDmg = (finalStats.bossDmg || 0) + value; applied = true;
                    } else if (desc.includes('урон стихиями')) {
                        finalStats.elementalDmgPercent = (finalStats.elementalDmgPercent || 0) + value; applied = true;
                    } else if (desc.includes('макс. мана') || desc.includes('мана')) {
                        finalStats.maxMana = (finalStats.maxMana || 0) + value; applied = true;
                    } else if (desc.includes('шанс уклонения') || desc.includes('уклонение')) {
                        finalStats.evasion = (finalStats.evasion || 0) + value; applied = true;
                    } else if (desc.includes('скорость передвижения')) { // Expects % bonus for move speed from sets
                        finalStats.moveSpeedPercentBonus = (finalStats.moveSpeedPercentBonus || 0) + value; applied = true;
                    } else if (desc.includes('+1 доп. снаряд при атаке') || desc.includes('доп. снаряд')) { // simplified
                         finalStats.bonusProjectiles = (finalStats.bonusProjectiles || 0) + 1; applied = true; // Assumes +1 always
                    }
                    if (!applied) console.warn(`[WARN] Не удалось распознать бонус сета '${set.name}': ${bonus.description}`);
                }
            });
        });

        // Apply percentage bonuses
        finalStats.attack = (finalStats.attack || 0) * (1 + (finalStats.atkPercentBonus || 0) / 100);
        finalStats.attackSpeed = (finalStats.attackSpeed || DEFAULT_BASE_STATS.attackSpeed || 1.0) * (1 + totalGearAttackSpeedPercentBonus / 100);
        finalStats.speed = (finalStats.speed || DEFAULT_BASE_STATS.speed || 5) * (1 + (finalStats.moveSpeedPercentBonus || 0) / 100); // Apply moveSpeedPercentBonus to speed

        // Debuffs and Aura Application (applied last to the subtotal)
        let debuffLogMessages = [];
        let attackBeforeModification, hpBeforeModification;

        // Apply "other" debuffs first
        if (totalOtherDamageReductionPercent > 0 || totalOtherMaxHpReductionPercent > 0) {
            attackBeforeModification = finalStats.attack;
            hpBeforeModification = finalStats.hp;
            if (totalOtherDamageReductionPercent > 0) {
                finalStats.attack *= (1 - totalOtherDamageReductionPercent / 100);
                debuffLogMessages.push(`Attack reduced by ${totalOtherDamageReductionPercent}% (other debuff). (${attackBeforeModification.toFixed(1)} -> ${finalStats.attack.toFixed(1)})`);
            }
            if (totalOtherMaxHpReductionPercent > 0) {
                finalStats.hp *= (1 - totalOtherMaxHpReductionPercent / 100);
                debuffLogMessages.push(`HP reduced by ${totalOtherMaxHpReductionPercent}% (other debuff). (${hpBeforeModification.toFixed(1)} -> ${finalStats.hp.toFixed(1)})`);
            }
        }

        // Apply "weaken" debuffs
        if (totalWeakenDamageReductionPercent > 0 || totalWeakenMaxHpReductionPercent > 0) {
            attackBeforeModification = finalStats.attack;
            hpBeforeModification = finalStats.hp;
            if (totalWeakenDamageReductionPercent > 0) {
                finalStats.attack *= (1 - totalWeakenDamageReductionPercent / 100);
                debuffLogMessages.push(`Attack reduced by ${totalWeakenDamageReductionPercent}% (weaken debuff). (${attackBeforeModification.toFixed(1)} -> ${finalStats.attack.toFixed(1)})`);
            }
            if (totalWeakenMaxHpReductionPercent > 0) {
                finalStats.hp *= (1 - totalWeakenMaxHpReductionPercent / 100);
                debuffLogMessages.push(`HP reduced by ${totalWeakenMaxHpReductionPercent}% (weaken debuff). (${hpBeforeModification.toFixed(1)} -> ${finalStats.hp.toFixed(1)})`);
            }
        }
        
        // Apply weakening aura if active
        const auraIsActive = state.isAffectedByWeakeningAura;
        const auraStrengthPercent = 10; // Example strength, make configurable if needed
        if (auraIsActive) {
            attackBeforeModification = finalStats.attack;
            hpBeforeModification = finalStats.hp;
            finalStats.attack *= (1 - auraStrengthPercent / 100);
            debuffLogMessages.push(`Attack reduced by ${auraStrengthPercent}% (aura). (${attackBeforeModification.toFixed(1)} -> ${finalStats.attack.toFixed(1)})`);
            finalStats.hp *= (1 - auraStrengthPercent / 100);
            debuffLogMessages.push(`HP reduced by ${auraStrengthPercent}% (aura). (${hpBeforeModification.toFixed(1)} -> ${finalStats.hp.toFixed(1)})`);
        }

        if (debuffLogMessages.length > 0) {
            // console.log("Debuffs/Aura Applied:", debuffLogMessages.join('; '));
        }

        // Final clamping and formatting
        finalStats.hp = Math.max(1, Math.round(finalStats.hp || 0));
        finalStats.attack = Math.max(0, Math.round(finalStats.attack || 0)); // Attack can be 0
        finalStats.attackSpeed = parseFloat(Math.max(0.1, (finalStats.attackSpeed || 0)).toFixed(2));
        finalStats.critChance = Math.min(100, Math.max(0, Math.round(finalStats.critChance || 0)));
        finalStats.doubleStrikeChance = Math.min(100, Math.max(0, Math.round(finalStats.doubleStrikeChance || 0)));
        finalStats.speed = parseFloat(Math.max(0.1, (finalStats.speed || 0)).toFixed(2));
        finalStats.range = Math.max(1, Math.round(finalStats.range || 0));
        finalStats.skin = finalStats.skin || DEFAULT_BASE_STATS.skin; // Ensure skin is always set
        finalStats.defense = Math.max(0, Math.round(finalStats.defense || 0));
        finalStats.hpRegen = Math.max(0, parseFloat((finalStats.hpRegen || 0).toFixed(1)));
        finalStats.evasion = Math.min(90, Math.max(0, Math.round(finalStats.evasion || 0))); // Cap evasion at 90%
        finalStats.maxMana = Math.max(0, Math.round(finalStats.maxMana || 0));
        finalStats.elementalDmgPercent = Math.max(0, Math.round(finalStats.elementalDmgPercent || 0));
        finalStats.goldFind = Math.max(0, Math.round(finalStats.goldFind || 0));
        finalStats.luck = Math.max(0, Math.round(finalStats.luck || 0));
        finalStats.bossDmg = Math.max(0, Math.round(finalStats.bossDmg || 0));
        finalStats.shardFind = Math.max(0, Math.round(finalStats.shardFind || 0));
        finalStats.bonusProjectiles = Math.max(0, Math.round(finalStats.bonusProjectiles || 0));

        // Ensure no NaN values
        for (const key in finalStats) {
            if (typeof finalStats[key] === 'number' && isNaN(finalStats[key])) {
                console.warn(`Computed stat ${key} was NaN. Resetting to default.`);
                finalStats[key] = DEFAULT_BASE_STATS[key] ?? 0;
            }
        }
        return finalStats;
    },
    isAnyRecipeCraftable: () => { // Unchanged from code2
        const { inventory, gold, diamonds } = get();
        const inventoryCounts = {};
        inventory.forEach(item => {
            if (item?.id && item?.rarity) { // For items where rarity matters for recipe
                const key = `${item.id}_${item.rarity}`;
                inventoryCounts[key] = (inventoryCounts[key] || 0) + 1;
            } else if (item?.id) { // For items where only ID matters
                inventoryCounts[item.id] = (inventoryCounts[item.id] || 0) + 1;
            }
        });

        for (const recipe of forgeRecipes) {
            let hasEnoughItems = true;
            for (const input of recipe.inputItems) {
                const key = input.rarity ? `${input.itemId}_${input.rarity}` : input.itemId;
                if ((inventoryCounts[key] || 0) < input.quantity) {
                    hasEnoughItems = false;
                    break;
                }
            }
            if (!hasEnoughItems) continue;

            if (gold >= recipe.cost.gold && diamonds >= recipe.cost.diamonds) {
                return true; // Found a craftable recipe
            }
        }
        return false; // No recipe is craftable
    },
    getAchievementXpNeededForNextLevel: () => getXpNeededForLevel(get().achievementLevel),
    getCurrentLevelXpProgress: () => Math.max(0, get().achievementXp - (ACHIEVEMENT_LEVEL_XP_THRESHOLDS[get().achievementLevel] ?? 0)),
    getXpNeededForCurrentLevelUp: () => {
        const lvl = get().achievementLevel;
        const nextThreshold = getXpNeededForLevel(lvl);
        const currentThreshold = ACHIEVEMENT_LEVEL_XP_THRESHOLDS[lvl] ?? 0;
        return nextThreshold === Infinity ? Infinity : nextThreshold - currentThreshold;
    },

    // ================== Действия (Actions) - Объединенные и Дополненные ==================
    setUsername: (name) => set({ username: name }),
    setGold: (amount) => set({ gold: amount }),
    setDiamonds: (amount) => set({ diamonds: amount }),
    setTelegramPhotoUrl: (photoUrl) => set({ userPhotoUrl: photoUrl || null }),
    setPlayerRace: (raceId) => get().initializeCharacterStats(raceId),
    initializeCharacterStats: (raceId) => {
        const raceData = getRaceDataById(raceId);
        const initialStats = raceData ? raceData.initialStats : DEFAULT_BASE_STATS;
        set({
            playerBaseStats: { ...initialStats },
            playerHp: initialStats.hp, // Initialize HP based on new base stats
            playerRace: raceId,
        });
        get().updatePowerLevel();
        get().initializeLevelHp(); // Recalculate and set current HP to max HP
    },
    playerTakeDamage: (damageAmount) => {
        set((state) => {
            const newHp = Math.max(0, state.playerHp - damageAmount);
            return { playerHp: newHp };
        });
        if (get().playerHp <= 0) {
            console.log("Игрок погиб!");
            // TODO: Handle player death (e.g., show game over screen, reset level)
        }
    },
    initializeLevelHp: () => {
        const maxHp = get().computedStats().hp;
        set({ playerHp: maxHp });
    },
    healPlayer: (amount) => {
        set((state) => {
            const maxHp = get().computedStats().hp;
            const newHp = Math.min(maxHp, state.playerHp + amount);
            return { playerHp: newHp };
        });
    },
    addGold: (amount) => {
        if (amount === 0) return;
        set((state) => ({
            gold: state.gold + amount,
            totalGoldCollected: amount > 0 ? state.totalGoldCollected + amount : state.totalGoldCollected,
        }));
        get().checkAllAchievements();
    },
    addDiamonds: (amount) => {
        if (amount === 0) return;
        set((state) => ({ diamonds: state.diamonds + amount }));
        get().checkAllAchievements(); // Check if any diamond-related achievements are met
    },
    // Modified to call trackTaskEvent
    incrementKills: (count = 1) => {
        set((state) => ({ totalKills: state.totalKills + count }));
        get().trackTaskEvent('kill_monster', count); // Universal task event tracker
        get().checkAllAchievements();
    },
    refillEnergyOnLoad: () => { // Unchanged from code2
        set((state) => {
            const now = Date.now();
            const { energyCurrent, energyMax, lastEnergyRefillTimestamp } = state;

            if (energyCurrent >= energyMax) {
                return { lastEnergyRefillTimestamp: now }; // Update timestamp if full to prevent large gains on next load if interval is small
            }

            const elapsedMs = now - (lastEnergyRefillTimestamp || now); // Ensure lastEnergyRefillTimestamp is not null
            if (elapsedMs <= 0) return {};

            const refillIntervalsPassed = Math.floor(elapsedMs / ENERGY_REFILL_INTERVAL_MS);
            if (refillIntervalsPassed <= 0) return {};

            const energyToAdd = refillIntervalsPassed;
            const newEnergy = Math.min(energyMax, energyCurrent + energyToAdd);

            // Calculate how much time was 'consumed' by the refill to set the new timestamp accurately
            const timeConsumedByRefillMs = (newEnergy - energyCurrent) * ENERGY_REFILL_INTERVAL_MS;
            const newTimestamp = (lastEnergyRefillTimestamp || (now - elapsedMs)) + timeConsumedByRefillMs;


            if (newEnergy === energyCurrent) return {}; // No change

            return {
                energyCurrent: newEnergy,
                lastEnergyRefillTimestamp: newTimestamp,
            };
        });
    },
    consumeEnergy: (cost) => { // Unchanged from code2
        if (cost <= 0) return false; // Or true if 0 cost means success
        let success = false;
        set((state) => {
            const { energyCurrent, energyMax, lastEnergyRefillTimestamp } = state;
            if (energyCurrent < cost) {
                console.warn(`Consume Energy: Недостаточно энергии. Нужно: ${cost}, есть: ${energyCurrent}`);
                success = false;
                return {}; // No change
            }

            const wasFull = energyCurrent >= energyMax;
            const newEnergy = energyCurrent - cost;
            // If energy was full, the refill timer starts now. Otherwise, it continues from last partial refill.
            const newTimestamp = wasFull ? Date.now() : lastEnergyRefillTimestamp;

            success = true;
            return {
                energyCurrent: newEnergy,
                lastEnergyRefillTimestamp: newTimestamp,
            };
        });
        return success;
    },
    addEnergy: (amount) => { // Unchanged from code2
        if (amount <= 0) return;
        set((state) => {
            const newEnergy = Math.min(state.energyMax, state.energyCurrent + amount);
            // If adding energy fills it up, update timestamp as if it just became full.
            // Otherwise, the existing lastEnergyRefillTimestamp logic for passive refill should remain.
            // This simple add doesn't typically reset the timer unless it hits max.
            // No explicit change to lastEnergyRefillTimestamp here, relying on passive refill logic.
            return { energyCurrent: newEnergy };
        });
    },
    setEquipped: (payload) => set({ equipped: payload }), // For direct state manipulation if needed
    addItemToInventory: (itemId, quantity = 1) => { // Unchanged from code2
        const baseItem = getItemById(itemId);
        if (baseItem) {
            const newItems = Array.from({ length: quantity }).map(() => createItemInstance(baseItem));
            set((state) => ({ inventory: [...state.inventory, ...newItems] }));
            get().checkAllAchievements(); // Check if collecting this item triggers an achievement
        } else {
            console.warn(`Предмет ${itemId} не найден в базе данных!`);
        }
    },
    removeItemFromInventory: (uid) => { // Unchanged from code2
        set((state) => ({
            inventory: state.inventory.filter(item => item.uid !== uid)
        }));
    },
    equipItem: (itemToEquip) => { // Unchanged from code2
        if (!itemToEquip?.type || !itemToEquip.uid) return;

        const slot = itemToEquip.type; // e.g., "weapon", "helmet"
        set((state) => {
            const currentEquippedItem = state.equipped[slot];
            // Filter out the item being equipped from inventory
            let updatedInventory = state.inventory.filter((i) => i.uid !== itemToEquip.uid);
            // If there was an item in the slot, add it back to inventory
            if (currentEquippedItem) {
                updatedInventory.push(currentEquippedItem);
            }

            let flagUpdate = {};
            if (itemToEquip.rarity && itemToEquip.rarity.toLowerCase() === 'epic' && !state.booleanFlags.equippedEpic) {
                flagUpdate = { booleanFlags: { ...state.booleanFlags, equippedEpic: true } };
            }
            // TODO: Add similar flags for other rarities if needed for achievements

            return {
                equipped: { ...state.equipped, [slot]: itemToEquip },
                inventory: updatedInventory,
                ...flagUpdate
            };
        });
        get().updatePowerLevel();
        get().initializeLevelHp(); // HP might change due to new item stats
    },
    unequipItem: (slot) => { // Unchanged from code2
        set((state) => {
            const itemToUnequip = state.equipped[slot];
            if (!itemToUnequip) return {}; // Nothing to unequip

            return {
                equipped: { ...state.equipped, [slot]: null }, // Clear the slot
                inventory: [...state.inventory, itemToUnequip], // Add item back to inventory
            };
        });
        get().updatePowerLevel();
        get().initializeLevelHp();
    },
    // Modified to call trackTaskEvent
    executeForgeRecipe: (recipe) => {
        if (!recipe?.inputItems || !recipe.outputItemId || !recipe.cost) {
            console.error("Forge Error: Invalid recipe data received.", recipe);
            return false;
        }
        const state = get();
        if (state.gold < recipe.cost.gold || state.diamonds < recipe.cost.diamonds) {
            console.warn("Forge Warning: Insufficient currency.");
            // alert("Недостаточно валюты!"); // Optional: provide user feedback
            return false;
        }

        const itemsToRemoveUids = new Set();
        let tempInventory = [...state.inventory]; // Work with a copy for finding items

        for (const input of recipe.inputItems) {
            let foundCount = 0;
            for (let i = 0; i < input.quantity; i++) {
                const itemIndex = tempInventory.findIndex(invItem =>
                    invItem.id === input.itemId &&
                    (input.rarity ? invItem.rarity === input.rarity : true) && // Check rarity if specified
                    !itemsToRemoveUids.has(invItem.uid) // Not already marked for removal for this recipe
                );

                if (itemIndex !== -1) {
                    itemsToRemoveUids.add(tempInventory[itemIndex].uid);
                    // Conceptually remove from tempInventory for this recipe's check if needed, or just use UIDs
                    foundCount++;
                } else {
                    console.error(`Forge Error: Insufficient items for input: ${input.itemId} (rarity: ${input.rarity || 'any'}), needed ${input.quantity}, found ${foundCount}`);
                    return false; // Cannot satisfy this input requirement
                }
            }
        }

        const outputItemBaseData = getItemById(recipe.outputItemId);
        if (!outputItemBaseData) {
            console.error(`Forge Error: Output item base data not found for ID: ${recipe.outputItemId}`);
            return false;
        }
        const forgedItem = createItemInstance(outputItemBaseData);
         if (!forgedItem) {
            console.error(`Forge Error: Could not create instance for output item ID: ${recipe.outputItemId}`);
            return false;
        }

        const currentForgeFlag = state.booleanFlags.hasForgedOrUpgraded;
        let flagUpdate = !currentForgeFlag ? { booleanFlags: { ...state.booleanFlags, hasForgedOrUpgraded: true } } : {};

        set((prevState) => {
            const newInventory = prevState.inventory.filter(item => !itemsToRemoveUids.has(item.uid));
            newInventory.push(forgedItem);
            return {
                inventory: newInventory,
                gold: prevState.gold - recipe.cost.gold,
                diamonds: prevState.diamonds - recipe.cost.diamonds,
                ...flagUpdate
            };
        });
        get().trackTaskEvent('upgrade_gear', 1); // Assuming forging counts as 'upgrade_gear'
        get().checkAllAchievements();
        return true;
    },
    purchaseShopItem: (dealId) => { // Unchanged from code2
        const state = get();
        const deal = state.dailyDeals.find(d => d.id === dealId);

        if (!deal) {
            console.error("Сделка не найдена в текущих dailyDeals:", dealId);
            return false;
        }
        if (state.dailyShopPurchases[dealId]) {
            console.warn("Товар уже куплен:", dealId);
            // alert("Товар уже куплен!"); // User feedback
            return false;
        }

        const currency = deal.currency; // 'gold' or 'diamonds'
        const price = deal.price;

        if (state[currency] < price) {
            alert(`Недостаточно ${currency}!`); // User feedback
            return false;
        }

        // Process item/shard addition
        if (deal.type === 'item') {
            get().addItemToInventory(deal.itemId, deal.quantity || 1);
        } else if (deal.type === 'artifact_shard') {
            get().addArtifactShards(deal.itemId, deal.quantity || 1);
        }
        // TODO: Add other deal types if necessary (e.g., direct currency purchase)

        const currentShopFlag = state.booleanFlags.hasMadeShopPurchase;
        let flagUpdate = !currentShopFlag ? { booleanFlags: { ...state.booleanFlags, hasMadeShopPurchase: true } } : {};


        set((prevState) => ({
            [currency]: prevState[currency] - price,
            dailyShopPurchases: { ...prevState.dailyShopPurchases, [dealId]: true },
            ...flagUpdate
        }));
        // NOTE: No specific task event for 'purchase_shop_item' in code1. If needed, add:
        // get().trackTaskEvent('purchase_item', 1);
        get().checkAllAchievements();
        return true;
    },
    setBooleanFlag: (flagName, value = true) => { // Unchanged from code2
        // Only set if it's a new true flag, or changing value.
        // Avoids redundant updates if already true and setting to true.
        if (get().booleanFlags[flagName] !== value) {
            set((state) => ({
                booleanFlags: { ...state.booleanFlags, [flagName]: value }
            }));
            get().checkAllAchievements(); // Check if this flag triggers any achievement
        }
    },
    // Modified to call trackTaskEvent
    completeLevelAction: (chapterId, levelId, difficulty, chapterContextData) => {
        const levelKey = `c${chapterId}_l${levelId}`;
        const currentCompletion = get().levelsCompleted[levelKey] || { normal: false, hard: false };
        let difficultyKey = difficulty?.toLowerCase() === 'hard' ? 'hard' : 'normal';
        
        let newLevelsCompleted = get().levelsCompleted;
        let needsUpdate = false;

        if (difficultyKey === 'normal' && !currentCompletion.normal) {
            newLevelsCompleted = {
                ...newLevelsCompleted,
                [levelKey]: { ...currentCompletion, normal: true }
            };
            needsUpdate = true;
        } else if (difficultyKey === 'hard' && !currentCompletion.hard) {
            newLevelsCompleted = {
                ...newLevelsCompleted,
                [levelKey]: { ...currentCompletion, normal: true, hard: true } // Completing hard also implies normal
            };
            needsUpdate = true;
        }

        if (needsUpdate) {
            set({ levelsCompleted: newLevelsCompleted });
            get().trackTaskEvent('complete_level', 1);
            get().checkAllAchievements();

            // Check for zone completion if this level was part of a zone boss chapter
            if (chapterContextData?.isZoneBossChapter && chapterContextData?.currentZoneIdForThisChapter) {
                const levelsForThisChapter = chapterContextData.levels || [];
                if (get().isChapterCompleted(chapterId, levelsForThisChapter)) { // Assumes isChapterCompleted checks based on new state
                    get().completeZone(chapterContextData.currentZoneIdForThisChapter);
                }
            }
        } else {
            // console.log(`[Store Action] Уровень ${levelKey} уже был пройден на сложности '${difficultyKey}' или выше.`);
        }
    },
    claimAchievementReward: (achievementId) => { // Unchanged from code2, ensure it's complete
        const state = get();
        const currentStatuses = state.achievementsStatus;
        const status = currentStatuses[achievementId] || { completed: false, claimed: false, progress: 0 };
        const definition = achievementsData.find(ach => ach.id === achievementId);

        if (!definition) {
            console.error(`Achievement definition not found for ID: ${achievementId}`);
            return;
        }

        // Double-check completion status based on current game state, as checkAllAchievements might not have run
        let isCompleted = status.completed;
        if (!isCompleted) { // Re-evaluate if not marked completed yet
            if (definition.condition.type === 'counter') {
                isCompleted = (state[definition.condition.stat] ?? 0) >= definition.condition.target;
            } else if (definition.condition.type === 'boolean') {
                isCompleted = state.booleanFlags[definition.condition.flag] === true;
            } else if (definition.condition.type === 'level_complete') {
                const levelKey = `c${definition.condition.chapterId}_l${definition.condition.levelId}`;
                const levelStatus = state.levelsCompleted[levelKey];
                isCompleted = !!(levelStatus && (levelStatus.normal || levelStatus.hard)); // Normal or hard completion
            }
        }

        if (!isCompleted || status.claimed) {
             // console.log(`Cannot claim achievement ${achievementId}: Completed: ${isCompleted}, Claimed: ${status.claimed}`);
            return;
        }

        let newStateChanges = {
            achievementsStatus: { ...currentStatuses, [achievementId]: { ...status, completed: true, claimed: true } }
        };

        let finalGold = state.gold;
        let finalDiamonds = state.diamonds;
        let finalInventoryAdditions = [];
        let finalTotalGoldCollected = state.totalGoldCollected; // Keep track for achievements related to gold collection

        if (definition.reward?.gold > 0) {
            finalGold += definition.reward.gold;
            finalTotalGoldCollected += definition.reward.gold; // Only count positive gold gain
        }
        if (definition.reward?.diamonds > 0) {
            finalDiamonds += definition.reward.diamonds;
        }
        if (definition.reward?.items?.length > 0) {
            definition.reward.items.forEach(rewardItem => {
                const itemBase = getItemById(rewardItem.itemId);
                if (itemBase) {
                    for (let i = 0; i < (rewardItem.quantity || 1); i++) {
                        const newItem = createItemInstance(itemBase);
                        if(newItem) finalInventoryAdditions.push(newItem);
                    }
                } else {
                    console.warn(`Item base not found for achievement reward: ${rewardItem.itemId}`);
                }
            });
        }

        const xpGained = definition.xpGain || 0;
        if (xpGained > 0) {
            let currentXp = state.achievementXp + xpGained;
            let currentLevel = state.achievementLevel;
            let xpNeededForNext = getXpNeededForLevel(currentLevel); // Uses currentLevel from state
            let levelUpOccurred = false;
            let totalLevelUpRewardGold = 0;
            let totalLevelUpRewardDiamonds = 0;

            while (currentXp >= xpNeededForNext && xpNeededForNext !== Infinity) {
                levelUpOccurred = true;
                currentLevel++; // Tentative new level
                const levelReward = ACHIEVEMENT_LEVEL_REWARDS[currentLevel];
                if (levelReward) {
                    if (levelReward.gold) totalLevelUpRewardGold += levelReward.gold;
                    if (levelReward.diamonds) totalLevelUpRewardDiamonds += levelReward.diamonds;
                }
                xpNeededForNext = getXpNeededForLevel(currentLevel); // XP needed for the *next* tentative level
            }

            finalGold += totalLevelUpRewardGold;
            finalDiamonds += totalLevelUpRewardDiamonds;
            if (totalLevelUpRewardGold > 0) finalTotalGoldCollected += totalLevelUpRewardGold;

            newStateChanges.achievementXp = currentXp;
            if (levelUpOccurred) {
                newStateChanges.achievementLevel = currentLevel; // Set the final achieved level
            }
        }

        newStateChanges.gold = finalGold;
        newStateChanges.diamonds = finalDiamonds;
        newStateChanges.totalGoldCollected = finalTotalGoldCollected;

        set(prevState => ({
            ...newStateChanges,
            inventory: [...prevState.inventory, ...finalInventoryAdditions]
        }));

        get().checkAllAchievements(); // Re-check in case claiming one unlocks another or updates indicator
    },
    checkAllAchievements: () => { // Unchanged from code2
        const state = get();
        let changed = false;
        const currentStatuses = state.achievementsStatus;
        const newStatuses = { ...currentStatuses };
        let hasUnclaimed = false;

        for (const achDef of achievementsData) {
            const status = newStatuses[achDef.id] || { progress: 0, completed: false, claimed: false };
            if (status.claimed) { // Skip if already claimed
                if(status.completed) hasUnclaimed = false; // Should not happen if claimed, but safety
                continue;
            }

            let isNowCompleted = status.completed;
            let currentProgress = status.progress;

            if (achDef.condition.type === 'counter') {
                currentProgress = state[achDef.condition.stat] ?? 0;
                isNowCompleted = currentProgress >= achDef.condition.target;
            } else if (achDef.condition.type === 'boolean') {
                isNowCompleted = state.booleanFlags[achDef.condition.flag] === true;
                currentProgress = isNowCompleted ? 1 : 0; // For boolean, progress is 0 or 1
            } else if (achDef.condition.type === 'level_complete') {
                const levelKey = `c${achDef.condition.chapterId}_l${achDef.condition.levelId}`;
                const levelStatus = state.levelsCompleted[levelKey];
                isNowCompleted = !!(levelStatus && (levelStatus.normal || levelStatus.hard) );
                currentProgress = isNowCompleted ? 1 : 0;
            }
            // TODO: Add more achievement condition types if needed

            if ((isNowCompleted && !status.completed) || (achDef.condition.type === 'counter' && currentProgress !== status.progress && !status.completed) ) {
                newStatuses[achDef.id] = { ...status, progress: currentProgress, completed: isNowCompleted };
                changed = true;
            }
            
            // Check for unclaimed using the potentially updated status from newStatuses
            if (newStatuses[achDef.id]?.completed && !newStatuses[achDef.id]?.claimed) {
                hasUnclaimed = true;
            }
        }

        if (changed) {
            set({ achievementsStatus: newStatuses });
        }
        get().setHasClaimableRewardsIndicator(hasUnclaimed);
    },
    generateDailyDeals: () => { // Unchanged from code2
        const itemPool = itemsDatabase
            .filter(item => item && DAILY_DEAL_RARITY_WEIGHTS[item.rarity.toLowerCase()] !== undefined)
            .map(item => ({ type: 'item', data: item, rarity: item.rarity }));

        const artifactsForShards = ALL_ARTIFACTS_ARRAY
            .filter(art => art && DAILY_DEAL_RARITY_WEIGHTS[art.rarity.toLowerCase()] !== undefined);
        const shardPool = artifactsForShards
            .map(artifact => ({ type: 'artifact_shard', data: artifact, rarity: artifact.rarity }));

        const combinedPool = [...itemPool, ...shardPool];

        if (combinedPool.length === 0) {
            console.error("Пул для ежедневных предложений пуст!");
            set({ dailyDeals: [], dailyDealsLastGenerated: Date.now(), dailyShopPurchases: {} });
            return;
        }

        const weightedPool = combinedPool.map(entry => {
            if (!entry || !entry.rarity || !entry.data) {
                console.warn("Некорректный entry в combinedPool:", entry);
                return null; // Will be filtered out
            }
            return {
                item: entry, // This is {type, data, rarity}
                weight: DAILY_DEAL_RARITY_WEIGHTS[entry.rarity.toLowerCase()] || 1
            };
        }).filter(Boolean); // Remove null entries

        if (weightedPool.length === 0) {
            console.error("Weighted pool for daily deals is empty after filtering!");
            set({ dailyDeals: [], dailyDealsLastGenerated: Date.now(), dailyShopPurchases: {} });
            return;
        }


        const numberOfDeals = 6;
        const generatedDeals = [];
        const selectedItemIds = new Set(); // To ensure unique items/shards in deals
        let currentWeightedPool = [...weightedPool]; // Copy to allow modification
        let iterations = 0; // Safety break for the loop

        while (generatedDeals.length < numberOfDeals && currentWeightedPool.length > 0 && iterations < 1000) {
            iterations++;
            const selectedEntryWrapper = weightedRandom(currentWeightedPool); // selectedEntryWrapper = {item: entry, weight: X}
             if (!selectedEntryWrapper || !selectedEntryWrapper.item || !selectedEntryWrapper.item.data) {
                // This can happen if weightedRandom returns null or an incomplete wrapper
                // Try to remove the problematic element if possible, or break
                const problemIndex = currentWeightedPool.findIndex(poolEntry => poolEntry === selectedEntryWrapper);
                if (problemIndex !== -1) {
                    currentWeightedPool.splice(problemIndex, 1);
                } else if (currentWeightedPool.length > 0) { // If cannot find specific, remove a random one to avoid infinite loop
                    currentWeightedPool.splice(Math.floor(Math.random() * currentWeightedPool.length), 1);
                }
                continue;
            }
            const selectedEntry = selectedEntryWrapper.item; // This is {type, data, rarity}

            const selectedIndexInPool = currentWeightedPool.findIndex(poolEntry => poolEntry.item === selectedEntry);


            const uniqueKey = `${selectedEntry.type}_${selectedEntry.data.id}`;
            if (!selectedItemIds.has(uniqueKey)) {
                selectedItemIds.add(uniqueKey);

                let quantity = 1;
                let currency = (Math.random() < 0.7) ? 'gold' : 'diamonds'; // 70% chance for gold
                let price = 100; // Base price
                const rarityMultiplier = { common: 1, uncommon: 3, rare: 10, legendary: 30, mythic: 100 }; // Example multipliers

                if (selectedEntry.type === 'item') {
                    price = (selectedEntry.data.basePrice || 100) * (rarityMultiplier[selectedEntry.rarity.toLowerCase()] || 1);
                    quantity = 1; // Typically 1 for items unless stackable items are sold
                } else if (selectedEntry.type === 'artifact_shard') {
                    // Shards might be cheaper or sold in small stacks
                    price = (selectedEntry.data.baseShardCost || 50) * (rarityMultiplier[selectedEntry.rarity.toLowerCase()] || 1);
                    quantity = Math.random() < 0.5 ? 3 : 5; // e.g., 3 or 5 shards
                    if (selectedEntry.rarity.toLowerCase() === 'rare' || selectedEntry.rarity.toLowerCase() === 'legendary' || selectedEntry.rarity.toLowerCase() === 'mythic') {
                        currency = 'diamonds'; // Higher rarity shards for diamonds
                    }
                    price = Math.round(price * quantity / (currency === 'diamonds' ? 10 : 1)); // Adjust price for stacks/currency
                }

                price = Math.max(currency === 'diamonds' ? 1 : 10, Math.round(price * (0.8 + Math.random() * 0.4))); // 80-120% of calculated price

                const dealId = `daily_${uniqueKey}_${Date.now()}_${generatedDeals.length}`;
                const newDealObject = {
                    id: dealId,
                    type: selectedEntry.type,
                    itemId: selectedEntry.data.id, // This is the ID of the item or artifact
                    name: selectedEntry.data.name, // For display
                    icon: selectedEntry.data.image || selectedEntry.data.icon, // For display
                    quantity: quantity,
                    currency: currency,
                    price: price,
                    rarity: selectedEntry.rarity, // For display styling
                    discount: 0, // Placeholder for potential future discounts
                    purchaseLimit: 1, // How many times this specific deal can be bought
                };
                generatedDeals.push(newDealObject);
            }

            // Remove the selected item from the pool to avoid re-selection if we are not allowing duplicates
            // OR if we just want to ensure the loop terminates if the pool is exhausted.
            if (selectedIndexInPool !== -1) {
                currentWeightedPool.splice(selectedIndexInPool, 1);
            } else {
                // This case should ideally not be hit if selectedEntryWrapper was valid
                if (currentWeightedPool.length > 0) currentWeightedPool.shift(); // Fallback: remove first to ensure progress
            }

             if (currentWeightedPool.length === 0 && generatedDeals.length < numberOfDeals) {
                // console.warn("Ran out of unique items for daily deals before filling all slots.");
                break; // Stop if pool is exhausted
            }
        }
         if (iterations >= 999) {
            console.error("[generateDailyDeals] Превышено максимальное количество итераций!");
        }

        set({
            dailyDeals: generatedDeals,
            dailyDealsLastGenerated: Date.now(),
            dailyShopPurchases: {} // Reset purchases with new deals
        });
    },
    checkAndRefreshDailyDeals: () => { // Unchanged from code2
        const state = get();
        const lastGeneratedTs = state.dailyDealsLastGenerated;
        const nowTs = Date.now();

        if (!lastGeneratedTs) {
            get().generateDailyDeals();
            return;
        }

        const nowUtcDate = new Date(nowTs);
        // Calculate the timestamp for today's refresh hour in UTC
        const targetTodayUtcTs = Date.UTC(
            nowUtcDate.getUTCFullYear(),
            nowUtcDate.getUTCMonth(),
            nowUtcDate.getUTCDate(),
            REFRESH_HOUR_UTC, 0, 0, 0
        );

        let lastRefreshMarkerTs;
        // If current time is past or at today's refresh time
        if (nowTs >= targetTodayUtcTs) {
            lastRefreshMarkerTs = targetTodayUtcTs;
        } else {
            // If current time is before today's refresh time, the last refresh point was yesterday's refresh time
            const targetYesterdayUtcTs = Date.UTC(
                nowUtcDate.getUTCFullYear(),
                nowUtcDate.getUTCMonth(),
                nowUtcDate.getUTCDate() - 1, // Yesterday
                REFRESH_HOUR_UTC, 0, 0, 0
            );
            lastRefreshMarkerTs = targetYesterdayUtcTs;
        }

        if (lastGeneratedTs < lastRefreshMarkerTs) {
            get().generateDailyDeals();
        } else {
            // If deals are empty but shouldn't be (e.g. after a load error that wiped them), try to restore or regenerate
            if (state.dailyDeals.length === 0 && savedState.dailyDeals && savedState.dailyDeals.length > 0) {
                 set({ dailyDeals: savedState.dailyDeals, dailyShopPurchases: savedState.dailyShopPurchases || {} }); // Restore from initial load if possible
            } else if (state.dailyDeals.length === 0) {
                // This case might happen if savedState also had no deals, but a refresh is not yet due.
                // Could be an edge case after a reset or first load where deals weren't generated yet.
                // console.log("Daily deals are empty, but refresh time not yet passed. Consider initial generation if needed.");
            }
        }
    },
    collectArtifact: (artifactId) => { // Unchanged from code2
        const artifactData = getArtifactById(artifactId);
        if (!artifactData) {
            console.warn(`Artifact data not found for ID: ${artifactId}`);
            return;
        }

        set((state) => {
            if (state.collectedArtifacts.has(artifactId)) {
                // console.log(`Artifact ${artifactId} already collected.`);
                return {}; // No change if already collected
            }

            const newCollected = new Set(state.collectedArtifacts);
            newCollected.add(artifactId);

            const newLevels = { ...state.artifactLevels };
            if (!newLevels[artifactId]) { // Initialize level and shards if not present
                newLevels[artifactId] = { level: 0, shards: 0 }; // Typically collected at level 0, activated to level 1
            }

            return {
                collectedArtifacts: newCollected,
                artifactLevels: newLevels,
            };
        });
        get().updatePowerLevel();
        get().checkAllAchievements(); // Check if collecting this triggers an achievement
    },
    addArtifactShards: (artifactId, amount) => { // Unchanged from code2
        if (amount <= 0) return;
        const artifactData = getArtifactById(artifactId);
        if (!artifactData) {
            console.warn(`Попытка добавить осколки для несуществующего артефакта: ${artifactId}`);
            return;
        }

        set((state) => {
            const currentInfo = state.artifactLevels[artifactId] || { level: 0, shards: 0 };
            // If artifact not in collectedArtifacts yet, add it
            let newCollectedArtifacts = state.collectedArtifacts;
            if (!state.collectedArtifacts.has(artifactId)) {
                newCollectedArtifacts = new Set(state.collectedArtifacts);
                newCollectedArtifacts.add(artifactId);
                // console.log(`Artifact ${artifactId} added to collected list by receiving shards.`);
            }

            const newShards = currentInfo.shards + amount;
            return {
                artifactLevels: {
                    ...state.artifactLevels,
                    [artifactId]: { ...currentInfo, shards: newShards }
                },
                ...(newCollectedArtifacts !== state.collectedArtifacts && { collectedArtifacts: newCollectedArtifacts })
            };
        });
        // No power level update for just shards, only on level up/activation
    },
    activateArtifact: (artifactId) => { // Unchanged from code2, ensure logic is sound
        const artifactData = getArtifactById(artifactId);
        if (!artifactData) { console.error("Арт не найден:", artifactId); return; }

        set((state) => {
            const currentInfo = state.artifactLevels[artifactId] || { level: 0, shards: 0 };
            if (currentInfo.level !== 0) { // Can only activate if at level 0
                console.warn(`Попытка активировать уже активный/улучшенный (${currentInfo.level}) артефакт: ${artifactId}`);
                return {};
            }

            // Cost to activate (go from level 0 to level 1)
            const shardsNeeded = (0 + 1) * (artifactData.baseShardCost || BASE_SHARD_COST_PER_LEVEL[artifactData.rarity.toLowerCase()] || 10); // Use specific or default cost

            if (currentInfo.shards < shardsNeeded) {
                // console.warn(`Недостаточно осколков для активации ${artifactId}. Нужно: ${shardsNeeded}, есть: ${currentInfo.shards}`);
                // alert("Недостаточно осколков!");
                return {};
            }

            const remainingShards = currentInfo.shards - shardsNeeded;
            const newCollected = new Set(state.collectedArtifacts); // Ensure it's in collected set
            newCollected.add(artifactId);

            return {
                collectedArtifacts: newCollected,
                artifactLevels: {
                    ...state.artifactLevels,
                    [artifactId]: { level: 1, shards: remainingShards }
                }
            };
        });
        get().updatePowerLevel();
        get().checkAllAchievements();
        get().initializeLevelHp(); // Stats might change
    },
    upgradeArtifact: (artifactId) => { // Unchanged from code2, ensure logic is sound
        const artifactData = getArtifactById(artifactId);
        if (!artifactData) { console.error("Арт не найден:", artifactId); return; }

        set((state) => {
            const currentInfo = state.artifactLevels[artifactId];
            if (!currentInfo || currentInfo.level === 0) { // Must be activated (level > 0)
                console.warn(`Попытка улучшить неактивированный или несуществующий артефакт: ${artifactId}`);
                return {};
            }

            const currentLevel = currentInfo.level;
            const maxLevel = artifactData.maxLevel || MAX_ARTIFACT_LEVEL; // Use specific or global max

            if (currentLevel >= maxLevel) {
                // console.log(`Артефакт ${artifactId} уже на максимальном уровне (${currentLevel}).`);
                // alert("Артефакт уже на максимальном уровне!");
                return {};
            }

            // Cost to upgrade to next level (currentLevel + 1)
            const shardsNeeded = (currentLevel + 1) * (artifactData.baseShardCost || BASE_SHARD_COST_PER_LEVEL[artifactData.rarity.toLowerCase()] || 10);

            if (currentInfo.shards < shardsNeeded) {
                // console.warn(`Недостаточно осколков для улучшения ${artifactId}. Нужно: ${shardsNeeded}, есть: ${currentInfo.shards}`);
                // alert("Недостаточно осколков!");
                return {};
            }

            const newLevel = currentLevel + 1;
            const remainingShards = currentInfo.shards - shardsNeeded;

            return {
                artifactLevels: {
                    ...state.artifactLevels,
                    [artifactId]: { level: newLevel, shards: remainingShards }
                }
            };
        });
        get().updatePowerLevel();
        get().checkAllAchievements();
        get().initializeLevelHp(); // Stats might change
    },
    updatePowerLevel: () => { // Unchanged from code2
        const { equipped, artifactLevels, collectedArtifacts } = get();
        let totalPower = 0;

        // Power from equipped items
        Object.values(equipped).filter(Boolean).forEach(item => { // Filter(Boolean) removes null/undefined items
            const itemLevel = item?.currentLevel || 0; // Assuming items can have levels
            const basePower = item?.basePowerLevel || 0;
            const powerPerLvl = item?.powerPerLevel || 0; // Power gained per item level
            const currentItemPower = basePower + (powerPerLvl * itemLevel);
            totalPower += Math.round(currentItemPower);
        });

        // Power from artifacts
        for (const artifactId in artifactLevels) {
            if (collectedArtifacts.has(artifactId)) {
                const level = artifactLevels[artifactId]?.level || 0;
                if (level > 0) { // Only count power if artifact is active (level > 0)
                    const artifactData = getArtifactById(artifactId);
                    if (artifactData) {
                        const artifactBasePower = artifactData.basePowerLevel || 0;
                        const artifactPowerPerLevel = artifactData.powerLevelPerLevel || 0; // Power gained per artifact level
                        const currentArtifactPower = artifactBasePower + (artifactPowerPerLevel * (level -1) ); // level 1 uses base, level 2 = base + 1*perlevel
                        totalPower += Math.round(currentArtifactPower);
                    } else {
                        console.warn(`Данные для артефакта ${artifactId} не найдены при расчете PL.`);
                    }
                }
            }
        }
        const finalPowerLevel = Math.max(0, totalPower);
        if (get().powerLevel !== finalPowerLevel) { // Only set if changed
           set({ powerLevel: finalPowerLevel });
        }
    },
    addItemToInventoryLogic: (currentInventory, itemData) => { // Helper, unchanged from code2
        const newItemInstance = createItemInstance(itemData);
        if(!newItemInstance) return currentInventory; // Should not happen if itemData is valid
        return [...currentInventory, newItemInstance];
    },
    // Modified to call trackTaskEvent
    openGearChest: (chestId) => {
        const state = get();
        const chestData = getGearChestById(chestId);
        if (!chestData) {
            console.error(`[GearChest] Сундук с ID ${chestId} не найден в gearChestData.js.`);
            return;
        }

        const cost = chestData.cost;
        if (state[cost.currency] < cost.price) {
            alert(`Недостаточно ${cost.currency}! Нужно ${cost.price}`);
            return;
        }

        const currentPity = state.gearChestPity[chestId] || {}; // Pity is per chest type
        let nextPity = { ...currentPity }; // Copy to modify
        let guaranteedRarity = null;
        let finalRarity = null;

        // Apply pity increment before rolling
        if (chestData.pity) {
            const pityConfigs = Array.isArray(chestData.pity) ? chestData.pity : [chestData.pity];
            pityConfigs.forEach(p => {
                const key = p.rarity.toLowerCase(); // e.g., 'epic', 'rare'
                nextPity[key] = (nextPity[key] || 0) + 1; // Increment pity counter for this rarity
            });

            // Check if pity limit reached for any rarity (highest first)
            const epicPityConfig = pityConfigs.find(p => p.rarity === 'Epic');
            if (epicPityConfig && nextPity.epic >= epicPityConfig.limit) {
                guaranteedRarity = 'Epic';
            } else {
                const rarePityConfig = pityConfigs.find(p => p.rarity === 'Rare');
                if (rarePityConfig && nextPity.rare >= rarePityConfig.limit) {
                    guaranteedRarity = 'Rare';
                }
                // Add more else-if for other pity rarities if needed
            }
        }

        if (guaranteedRarity) {
            finalRarity = guaranteedRarity;
        } else {
            finalRarity = _rollWeightedRarity_Gear(chestData.rarityChances);
        }

        const obtainedItemData = _selectRandomGearItemByRarity_Gear(finalRarity);
        if (!obtainedItemData) {
            console.error(`[GearChest] Не удалось получить предмет редкости ${finalRarity}. Отмена.`);
            // Optionally, refund cost or handle error more gracefully
            return;
        }
        const obtainedRarity = obtainedItemData.rarity; // Actual rarity of the item obtained

        // Reset pity if the guaranteed (or higher) rarity was obtained
        if (chestData.pity) {
            const pityConfigs = Array.isArray(chestData.pity) ? chestData.pity : [chestData.pity];
            if (obtainedRarity === 'Epic' && pityConfigs.some(p => p.rarity === 'Epic')) {
                nextPity.epic = 0; // Reset Epic pity
                if (pityConfigs.some(p => p.rarity === 'Rare')) nextPity.rare = 0; // Also reset lower pity like Rare
            } else if (obtainedRarity === 'Rare' && pityConfigs.some(p => p.rarity === 'Rare')) {
                nextPity.rare = 0; // Reset Rare pity
            }
        }

        const rewardDetails = { // For the rewards modal
            type: 'gear', id: obtainedItemData.id, name: obtainedItemData.name,
            icon: obtainedItemData.image, rarity: obtainedItemData.rarity, amount: 1,
        };

        set(prevState => {
            if (!prevState) { // Should not happen with Zustand
                console.error("[GearChest] prevState is undefined in set function!");
                return {};
            }
            return {
                [cost.currency]: prevState[cost.currency] - cost.price,
                totalGearChestsOpened: prevState.totalGearChestsOpened + 1,
                gearChestPity: { // Update pity for this specific chestId
                    ...prevState.gearChestPity,
                    [chestId]: nextPity
                },
                inventory: get().addItemToInventoryLogic(prevState.inventory, obtainedItemData),
                lastOpenedChestInfo: { chestId: chestId, amount: 1, type: 'gear', name: chestData.name },
                lastChestRewards: [rewardDetails]
            };
        });
        get().trackTaskEvent('open_chest', 1);
        get().checkAllAchievements();
    },
    // Modified to call trackTaskEvent
    openGearChestX10: (chestId) => {
        const state = get();
        const chestData = getGearChestById(chestId);
        if (!chestData) {
            console.error(`[GearChestX10] Сундук с ID ${chestId} не найден.`);
            return;
        }

        const cost = chestData.cost;
        const totalCost = cost.price * 10; // Assuming x10 cost is 10 times single cost
        // TODO: Consider discount for x10 pulls if applicable

        if (state[cost.currency] < totalCost) {
            alert(`Недостаточно ${cost.currency}! Нужно ${totalCost}`);
            return;
        }

        let workingPity = { ...(state.gearChestPity[chestId] || {}) }; // Start with current pity for this chest type
        const rewardsDetailed = [];
        const newItemInstances = []; // Accumulate new item instances

        for (let i = 0; i < 10; i++) {
            let guaranteedRarity = null;
            let finalRarity = null;

            if (chestData.pity) {
                const pityConfigs = Array.isArray(chestData.pity) ? chestData.pity : [chestData.pity];
                pityConfigs.forEach(p => {
                    const key = p.rarity.toLowerCase();
                    workingPity[key] = (workingPity[key] || 0) + 1;
                });

                const epicPityConfig = pityConfigs.find(p => p.rarity === 'Epic');
                if (epicPityConfig && workingPity.epic >= epicPityConfig.limit) {
                    guaranteedRarity = 'Epic';
                } else {
                    const rarePityConfig = pityConfigs.find(p => p.rarity === 'Rare');
                    if (rarePityConfig && workingPity.rare >= rarePityConfig.limit) {
                        guaranteedRarity = 'Rare';
                    }
                }
            }

            if (guaranteedRarity) {
                finalRarity = guaranteedRarity;
            } else {
                finalRarity = _rollWeightedRarity_Gear(chestData.rarityChances);
            }

            const obtainedItemData = _selectRandomGearItemByRarity_Gear(finalRarity);
            if (!obtainedItemData) {
                console.error(`  [Pull ${i + 1}] Не удалось получить предмет редкости ${finalRarity}! Пропускаем.`);
                rewardsDetailed.push({ type: 'error', name: `Ошибка получения ${finalRarity}` }); // Placeholder for error in UI
                continue; // Skip this pull if item selection failed
            }
            const obtainedRarity = obtainedItemData.rarity;

            if (chestData.pity) {
                const pityConfigs = Array.isArray(chestData.pity) ? chestData.pity : [chestData.pity];
                 if (obtainedRarity === 'Epic' && pityConfigs.some(p => p.rarity === 'Epic')) {
                    workingPity.epic = 0;
                    if (pityConfigs.some(p => p.rarity === 'Rare')) workingPity.rare = 0;
                } else if (obtainedRarity === 'Rare' && pityConfigs.some(p => p.rarity === 'Rare')) {
                    workingPity.rare = 0;
                }
            }
            const rewardDetails = { type: 'gear', ...obtainedItemData, amount: 1, icon: obtainedItemData.image }; // Spread item data
            rewardsDetailed.push(rewardDetails);
            const newItem = createItemInstance(obtainedItemData); // Create instance
            if(newItem) newItemInstances.push(newItem); // Add to list
        }

        set(prevState => {
            if (!prevState) return {}; // Should not happen
            return {
                [cost.currency]: prevState[cost.currency] - totalCost,
                totalGearChestsOpened: prevState.totalGearChestsOpened + 10,
                gearChestPity: {
                    ...prevState.gearChestPity,
                    [chestId]: workingPity // Save the final pity state after 10 pulls
                },
                inventory: [...prevState.inventory, ...newItemInstances], // Add all new items
                lastOpenedChestInfo: { chestId: chestId, amount: 10, type: 'gear', name: chestData.name },
                lastChestRewards: rewardsDetailed
            };
        });
        get().trackTaskEvent('open_chest', 10);
        get().checkAllAchievements();
    },
    processArtifactReward: (dropType, targetArtifactId) => { // Unchanged from code2
        if (!targetArtifactId) return { details: null, obtainedFullArtifact: false };
        const artifactData = getArtifactById(targetArtifactId);
        if (!artifactData) { console.error(`[ProcessArtifact] Data not found for ${targetArtifactId}`); return { details: null, obtainedFullArtifact: false }; }

        let rewardDetails = null;
        let obtainedFullArtifact = false; // Flag to indicate if a full artifact (new or dupe leading to activation) was processed

        if (dropType === 'artifact_shard') {
            const amount = 1; // Assuming 1 shard per "shard drop" type
            get().addArtifactShards(targetArtifactId, amount);
            rewardDetails = { type: 'artifact_shard', amount, artifactId: targetArtifactId, icon: artifactData.icon, name: `${artifactData.name} (осколок)`, rarity: artifactData.rarity };
        }
        else if (dropType === 'full_artifact') {
            obtainedFullArtifact = true; // This drop type IS a full artifact
            const currentArtifactState = get().artifactLevels[targetArtifactId];
            const isCollected = get().collectedArtifacts.has(targetArtifactId);
            const isActive = isCollected && currentArtifactState && currentArtifactState.level > 0;

            const shardAmountOnDuplicate = artifactData.shardValueOnDuplicate || 10; // Shards if already active L1+
            let isNewActivation = false;

            if (isActive) { // Already have it and it's L1+
                get().addArtifactShards(targetArtifactId, shardAmountOnDuplicate);
                rewardDetails = { type: 'full_artifact_duplicate', artifactId: targetArtifactId, isNew: false, shardAmount: shardAmountOnDuplicate, icon: artifactData.icon, name: artifactData.name, rarity: artifactData.rarity };
            } else { // Not active (level 0) or not even collected yet
                isNewActivation = true;
                // If not collected, collect it (adds to set, initializes level/shards to 0)
                if (!isCollected) {
                    get().collectArtifact(targetArtifactId); // This will add to collectedArtifacts and initialize artifactLevels[id] = {level:0, shards:0}
                }
                // Now, activate it to level 1.
                // The cost for level 1 activation is baseShardCost.
                // If it's a "full artifact drop", we assume it bypasses shard cost for L1.
                set(state => {
                     const newCollected = new Set(state.collectedArtifacts); // Ensure collected
                     newCollected.add(targetArtifactId);
                     return {
                        collectedArtifacts: newCollected,
                        artifactLevels: {
                            ...state.artifactLevels,
                            [targetArtifactId]: {
                                // Keep existing shards, set level to 1
                                shards: (state.artifactLevels[targetArtifactId]?.shards || 0),
                                level: 1,
                            }
                        }
                    };
                });
                get().updatePowerLevel(); // Since it's now L1
                rewardDetails = { type: 'full_artifact_new', artifactId: targetArtifactId, isNew: true, icon: artifactData.icon, name: artifactData.name, rarity: artifactData.rarity };
            }
        } else {
            console.warn("Unknown dropType in processArtifactReward:", dropType);
        }
        return { details: rewardDetails, obtainedFullArtifact: obtainedFullArtifact };
    },
    // Modified to call trackTaskEvent
    openArtifactChest: (chestId) => {
        const state = get();
        const chestData = getArtifactChestById(chestId);
        if (!chestData || !chestData.isEnabled) { console.error(`Сундук ${chestId} не найден или не активен.`); return; }
        if (state[chestData.cost.currency] < chestData.cost.price) { alert(`Недостаточно ${chestData.cost.currency}!`); return; }

        let currentPity = state.artifactChestPity[chestId] || 0;
        currentPity++; // Increment before roll
        const newTotalOpened = state.totalArtifactChestsOpened + 1;

        let rewardTypeObj = null;
        let obtainedFullArtifactDueToPity = false;

        if (currentPity >= chestData.pityLimit) {
            rewardTypeObj = chestData.rewardPool.find(r => r.type === 'full_artifact'); // Pity guarantees full artifact
            if (rewardTypeObj) obtainedFullArtifactDueToPity = true;
            else { // Fallback if pity type 'full_artifact' is somehow missing from pool
                console.warn(`Pity hit for ${chestId}, but 'full_artifact' type not in pool. Rolling normally.`);
                rewardTypeObj = selectWeightedRewardType(chestData.rewardPool);
            }
        } else {
            rewardTypeObj = selectWeightedRewardType(chestData.rewardPool);
        }

        if (!rewardTypeObj) { console.error("Не удалось определить тип награды."); return; }
        const rewardType = rewardTypeObj.type;
        let rewardProcessingResult = { details: null, obtainedFullArtifact: obtainedFullArtifactDueToPity };

        if (rewardType === 'gold') {
            const amount = Math.floor(Math.random() * (rewardTypeObj.max - rewardTypeObj.min + 1)) + rewardTypeObj.min;
            get().addGold(amount);
            rewardProcessingResult.details = { type: 'gold', amount, icon: '/assets/icons/currency/gold.png', name: 'Золото' }; // Use actual icon path
        } else if (rewardType === 'diamonds') {
            const amount = rewardTypeObj.amount;
            get().addDiamonds(amount);
            rewardProcessingResult.details = { type: 'diamonds', amount, icon: '/assets/icons/currency/diamond.png', name: 'Алмазы' }; // Use actual icon path
        } else if (rewardType === 'artifact_shard' || rewardType === 'full_artifact') {
            const targetArtifactId = _selectWeightedArtifactIdFromSet_ByRarity(chestData.setId);
            if (!targetArtifactId) { console.error("Не удалось выбрать артефакт из сета."); return; }
            // If pity guaranteed full artifact, ensure rewardType is 'full_artifact' for processing
            const typeToProcess = obtainedFullArtifactDueToPity ? 'full_artifact' : rewardType;
            rewardProcessingResult = get().processArtifactReward(typeToProcess, targetArtifactId);
        } else {
            console.warn(`Неизвестный тип награды из пула: ${rewardType}`);
        }

        let finalPityValue = currentPity;
        if (rewardProcessingResult.obtainedFullArtifact || obtainedFullArtifactDueToPity) { // Reset pity if full artifact obtained (by luck or pity)
            finalPityValue = 0;
        }

        set((prevState) => {
            if (!prevState) return {};
            return {
                [chestData.cost.currency]: prevState[chestData.cost.currency] - chestData.cost.price,
                artifactChestPity: { ...prevState.artifactChestPity, [chestId]: finalPityValue },
                totalArtifactChestsOpened: newTotalOpened,
                lastOpenedChestInfo: { chestId: chestId, amount: 1, type: 'artifact', name: chestData.name },
                lastChestRewards: rewardProcessingResult.details ? [rewardProcessingResult.details] : [],
            };
        });
        get().trackTaskEvent('open_chest', 1);
        get().checkAllAchievements();
        if(rewardProcessingResult.obtainedFullArtifact || rewardType === 'artifact_shard'){ // If artifact related, stats might change
            get().initializeLevelHp(); // Recalculate HP if stats changed
        }
    },
    // Modified to call trackTaskEvent
    openArtifactChestX10: (chestId) => {
        const state = get();
        const chestData = getArtifactChestById(chestId);
        if (!chestData || !chestData.isEnabled) { console.error(`Сундук ${chestId} не найден или не активен.`); return; }
        const totalCost = chestData.cost.price * 10; // Assuming no discount for x10
        if (state[chestData.cost.currency] < totalCost) { alert(`Недостаточно ${chestData.cost.currency}!`); return; }

        let workingPity = state.artifactChestPity[chestId] || 0;
        const newTotalOpened = state.totalArtifactChestsOpened + 10;
        const rewardsDetailed = []; // Array to hold details of each of the 10 drops
        let hasObtainedAnyArtifactMaterialInBatch = false; // For HP recalc

        for (let i = 0; i < 10; i++) {
            workingPity++; // Increment pity for this pull
            let rewardTypeObj = null;
            let obtainedFullArtifactThisPull = false;

            if (workingPity >= chestData.pityLimit) {
                rewardTypeObj = chestData.rewardPool.find(r => r.type === 'full_artifact');
                if (rewardTypeObj) obtainedFullArtifactThisPull = true;
                else rewardTypeObj = selectWeightedRewardType(chestData.rewardPool); // Fallback
            } else {
                rewardTypeObj = selectWeightedRewardType(chestData.rewardPool);
            }

            if (!rewardTypeObj) { console.error(`[X10 Pull ${i+1}] Failed type roll!`); rewardsDetailed.push({ type: 'error', name: 'Ошибка ролла типа' }); continue; }
            const rewardType = rewardTypeObj.type;
            let currentPullProcessingResult = { details: null, obtainedFullArtifact: obtainedFullArtifactThisPull };


            if (rewardType === 'gold') {
                const amount = Math.floor(Math.random() * (rewardTypeObj.max - rewardTypeObj.min + 1)) + rewardTypeObj.min;
                get().addGold(amount); // Add immediately
                currentPullProcessingResult.details = { type: 'gold', amount, icon: '/assets/icons/currency/gold.png', name: 'Золото' };
            } else if (rewardType === 'diamonds') {
                const amount = rewardTypeObj.amount;
                get().addDiamonds(amount); // Add immediately
                currentPullProcessingResult.details = { type: 'diamonds', amount, icon: '/assets/icons/currency/diamond.png', name: 'Алмазы' };
            } else if (rewardType === 'artifact_shard' || rewardType === 'full_artifact') {
                const targetArtifactId = _selectWeightedArtifactIdFromSet_ByRarity(chestData.setId);
                if (!targetArtifactId) { console.error(`[X10 Pull ${i+1}] Failed artifact selection!`); rewardsDetailed.push({ type: 'error', name: 'Ошибка выбора артефакта' }); continue; }
                const typeToProcess = obtainedFullArtifactThisPull ? 'full_artifact' : rewardType;
                currentPullProcessingResult = get().processArtifactReward(typeToProcess, targetArtifactId); // This handles adding shards/artifacts
                if(currentPullProcessingResult.obtainedFullArtifact || rewardType === 'artifact_shard') hasObtainedAnyArtifactMaterialInBatch = true;
            } else {
                 console.warn(`[X10 Pull ${i+1}] Unknown type: ${rewardType}`);
                 currentPullProcessingResult.details = { type: 'error', name: `Неизвестный тип ${rewardType}` };
            }

            if (currentPullProcessingResult.details) {
                rewardsDetailed.push(currentPullProcessingResult.details);
            } else { // Should not happen if all paths set details
                rewardsDetailed.push({ type: 'error', name: 'Ошибка обработки награды' });
            }

            if (currentPullProcessingResult.obtainedFullArtifact) { // If a full artifact was obtained in this pull (pity or luck)
                workingPity = 0; // Reset pity counter
            }
        }

        set((prevState) => ({
            [chestData.cost.currency]: prevState[chestData.cost.currency] - totalCost,
            artifactChestPity: { ...prevState.artifactChestPity, [chestId]: workingPity }, // Final pity after 10 pulls
            totalArtifactChestsOpened: newTotalOpened,
            lastOpenedChestInfo: { chestId: chestId, amount: 10, type: 'artifact', name: chestData.name },
            lastChestRewards: rewardsDetailed, // Array of 10 reward details
        }));
        get().trackTaskEvent('open_chest', 10);
        get().checkAllAchievements();
        if(hasObtainedAnyArtifactMaterialInBatch){
            get().initializeLevelHp();
        }
    },
    clearLastChestData: () => set({ // Unchanged from code2
        lastChestRewards: null,
        lastOpenedChestInfo: null
    }),
    resetLevelRewards: () => { // Unchanged from code2
        set({ currentLevelRewards: { gold: 0, diamonds: 0, items: [] } });
    },
    addLevelReward: (type, amountOrItem) => { // Unchanged from code2
        if (!type || amountOrItem === undefined || amountOrItem === null) return;

        if ((type === 'gold' || type === 'diamonds') && typeof amountOrItem === 'number' && amountOrItem > 0) {
            set((state) => {
                const currentAmount = state.currentLevelRewards[type] || 0;
                const newAmount = currentAmount + amountOrItem;
                return {
                    currentLevelRewards: { ...state.currentLevelRewards, [type]: newAmount }
                };
            });
        }
        else if (type === 'item' && typeof amountOrItem === 'object' && amountOrItem.id) {
             // Ensure we are storing a simple info object, not a full item instance for the summary
            const itemInfo = {
                id: amountOrItem.id,
                name: amountOrItem.name || 'Предмет',
                rarity: amountOrItem.rarity || 'Common',
                icon: amountOrItem.image || amountOrItem.icon || '/assets/icons/item_default.png' // Use existing icon or default
            };
            set((state) => ({
                currentLevelRewards: {
                    ...state.currentLevelRewards,
                    items: [...state.currentLevelRewards.items, itemInfo],
                }
            }));
        } else {
            console.warn(`[addLevelReward] Неверный тип или значение: ${type}`, amountOrItem);
        }
    },
    // Modified to call trackTaskEvent
    openLevelChest: (chestInstanceId, chestTypeId) => {
        const state = get();
        // Prevent re-opening if already opened (using levelChestStates)
        if (state.levelChestStates[chestInstanceId]) {
            // console.log(`Level chest ${chestInstanceId} already opened.`);
            return;
        }

        const chestTypeData = getLevelChestTypeById(chestTypeId);
        if (!chestTypeData) {
            console.error(`[openLevelChest] Не найдены данные для типа сундука: ${chestTypeId}`);
            return;
        }

        const lootTable = chestTypeData.lootTable;
        const generatedRewardsForPopup = []; // For the UI popup
        let collectedGoldThisChest = 0;
        let collectedDiamondsThisChest = 0;

        // Guaranteed rewards
        lootTable.guaranteed?.forEach(rewardEntry => {
            if (rewardEntry.type === 'gold' || rewardEntry.type === 'diamonds') {
                const amount = Math.floor(Math.random() * (rewardEntry.max - rewardEntry.min + 1)) + rewardEntry.min;
                if (amount > 0) {
                    if (rewardEntry.type === 'gold') {
                        get().addGold(amount); // Directly add to player's currency
                        collectedGoldThisChest += amount;
                    }
                    if (rewardEntry.type === 'diamonds') {
                        get().addDiamonds(amount); // Directly add to player's currency
                        collectedDiamondsThisChest += amount;
                    }
                    // For popup, use the same structure as addLevelReward expects for currency
                    generatedRewardsForPopup.push({
                        type: rewardEntry.type,
                        amount: amount,
                        // Add name/icon for consistency if popup needs it
                        name: rewardEntry.type === 'gold' ? 'Золото' : 'Алмазы',
                        icon: rewardEntry.type === 'gold' ? '/assets/icons/currency/gold.png' : '/assets/icons/currency/diamond.png'
                    });
                }
            }
            // TODO: Handle guaranteed items if lootTable supports it
        });

        // Add to currentLevelRewards (summary for end-of-level screen)
        if (collectedGoldThisChest > 0) get().addLevelReward('gold', collectedGoldThisChest);
        if (collectedDiamondsThisChest > 0) get().addLevelReward('diamonds', collectedDiamondsThisChest);

        // Item drop (random chance)
        if (lootTable.itemDrop && Math.random() < (lootTable.itemDrop.chance || 1.0)) { // Default 100% chance if not specified
            const rarityChances = lootTable.itemDrop.rarityChances;
            try {
                const chosenRarity = _rollWeightedRarity_Gear(rarityChances);
                const itemTemplate = _selectRandomGearItemByRarity_Gear(chosenRarity);
                if (itemTemplate) {
                    get().addItemToInventory(itemTemplate.id, 1); // Add to player's inventory
                    const itemRewardInfo = {
                        type: 'item', id: itemTemplate.id, name: itemTemplate.name,
                        rarity: itemTemplate.rarity, icon: itemTemplate.image
                    };
                    generatedRewardsForPopup.push(itemRewardInfo); // For popup
                    get().addLevelReward('item', itemTemplate); // For end-of-level summary (passes template)
                } else {
                    console.warn(`  - [Loot] Не удалось выбрать предмет редкости ${chosenRarity} для сундука уровня.`);
                }
            } catch (e) {
                console.error("Ошибка при генерации предмета из сундука уровня:", e);
            }
        }

        set({
            lastOpenedLevelChestRewards: generatedRewardsForPopup, // For immediate UI popup
            levelChestStates: { ...get().levelChestStates, [chestInstanceId]: true } // Mark as opened
        });
        get().trackTaskEvent('open_chest', 1); // Count as one chest opened for tasks

        const popupDuration = 4000; // Duration to show the popup
        setTimeout(() => {
            get().clearLastLevelChestRewards();
        }, popupDuration);
    },
    clearLastLevelChestRewards: () => { // Unchanged from code2
        if (get().lastOpenedLevelChestRewards !== null) { // Only update if not already null
            set({ lastOpenedLevelChestRewards: null });
        }
    },
    resetGame: () => { // Merged with code1's task reset fields
        const defaultEquipped = getDefaultEquippedSet();
        const defaultStateForTasksOnReset = { // From code1
            dailyTaskProgress: {}, dailyTaskBarXp: 0, dailyBonusClaimed: false, lastDailyReset: null,
            dailyLoginToday: false, killsToday: 0, levelsCompletedToday: 0, gearUpgradedToday: 0, chestsOpenedToday: 0,
            lastSeenLoginDateForWeekly: null, lastSeenLoginDateForMonthly: null,
            weeklyTaskProgress: {}, weeklyTaskBarXp: 0, weeklyBonusClaimed: false, lastWeeklyReset: null,
            weeklyLoginDays: 0, killsThisWeek: 0, levelsCompletedThisWeek: 0, gearUpgradedThisWeek: 0, chestsOpenedThisWeek: 0,
            monthlyTaskProgress: {}, monthlyTaskBarXp: 0, monthlyBonusClaimed: false, lastMonthlyReset: null,
            monthlyLoginDays: 0, killsThisMonth: 0, levelsCompletedThisMonth: 0, gearUpgradedThisMonth: 0, chestsOpenedThisMonth: 0,
        };
        set({
            gold: 100000, diamonds: 10000, username: null, powerLevel: 0, userPhotoUrl: null,
            playerBaseStats: { ...DEFAULT_BASE_STATS },
            playerHp: DEFAULT_BASE_STATS.hp,
            playerRace: null,
            inventory: [],
            equipped: defaultEquipped,
            dailyShopPurchases: {}, achievementsStatus: {}, totalGoldCollected: 0, totalKills: 0,
            booleanFlags: {}, levelsCompleted: {}, achievementLevel: 1, achievementXp: 0,
            collectedArtifacts: new Set(), artifactLevels: {}, artifactChestPity: {},
            gearKeys: 0, totalArtifactChestsOpened: 0, gearChestPity: {}, totalGearChestsOpened: 0,
            dailyDeals: [], dailyDealsLastGenerated: null, lastOpenedChestInfo: null, lastChestRewards: null,
            activeDebuffs: [], isAffectedByWeakeningAura: false,
            energyMax: DEFAULT_MAX_ENERGY, energyCurrent: DEFAULT_MAX_ENERGY, lastEnergyRefillTimestamp: Date.now(),
            treasureChestAttempts: 3, treasureChestLastReset: null,
            completedZones: {}, currentChapterId: INITIAL_CHAPTER_ID,
            levelChestStates: {}, lastOpenedLevelChestRewards: null,
            hasClaimableRewardsIndicator: false,
            ...defaultStateForTasksOnReset // Apply task defaults on reset
        });
        localStorage.removeItem(STORAGE_KEY); // Clear saved state
        get().updatePowerLevel(); // Recalculate power
        get().checkAndRefreshDailyDeals(); // Generate new deals
        get().initializeLevelHp(); // Set HP to max
        // Call task resets to ensure they are correctly initialized after a game reset
        get().checkAndResetDailyTasks();
        get().checkAndResetWeeklyTasks();
        get().checkAndResetMonthlyTasks();
        console.log("Game has been reset to default state.");
    },
    addDebuff: (debuff) => { // Unchanged from code2
        const newDebuff = {
            ...debuff,
            id: debuff.id || uuidv4(), // Ensure unique ID
            endTime: Date.now() + debuff.durationMs,
        };
        set(state => ({
            activeDebuffs: [...state.activeDebuffs, newDebuff]
        }));
        get().updatePowerLevel(); // Power level might change if debuffs affect stats directly or indirectly
        get().initializeLevelHp(); // Max HP might change
    },
    removeDebuff: (debuffId) => { // Unchanged from code2
        let changed = false;
        set(state => {
            const newDebuffs = state.activeDebuffs.filter(d => d.id !== debuffId);
            if (newDebuffs.length !== state.activeDebuffs.length) changed = true;
            return { activeDebuffs: newDebuffs };
        });
        if (changed) {
            get().updatePowerLevel();
            get().initializeLevelHp();
        }
    },
    clearExpiredDebuffs: () => { // Unchanged from code2
        const now = Date.now();
        const currentDebuffs = get().activeDebuffs;
        const activeDebuffs = currentDebuffs.filter(debuff => now < debuff.endTime);

        if (activeDebuffs.length < currentDebuffs.length) { // If any debuffs were removed
            set({ activeDebuffs });
            get().updatePowerLevel();
            get().initializeLevelHp();
        }
    },
    // 'applyDebuff' from code2 seems like a duplicate or alternative to 'addDebuff'.
    // Keeping 'addDebuff' as it's more descriptive if 'debuff' is an object.
    // If 'applyDebuff' was for simple type/duration/strength, it's fine too.
    // For now, commenting out the potentially redundant one or ensuring one is used consistently.
    /*
    applyDebuff: (type, duration, strength) => { // This was in code2
        const now = Date.now();
        const endTime = now + duration * 1000; // Assuming duration is in seconds
        const newDebuff = { id: uuidv4(), type, strength, endTime };
        set((state) => ({
            activeDebuffs: [...state.activeDebuffs, newDebuff],
        }));
        // No immediate HP/PL update here, relying on computedStats to reflect changes
    },
    */
    setWeakeningAuraStatus: (isActive) => { // Unchanged from code2
        if (get().isAffectedByWeakeningAura !== isActive) {
            set({ isAffectedByWeakeningAura: isActive });
            // computedStats will pick this up, and initializeLevelHp should be called if max HP changes
            get().initializeLevelHp();
            // updatePowerLevel might also be relevant if aura affects stats that contribute to it
            get().updatePowerLevel();
        }
    },
    // cleanupExpiredDebuffs in code2 is identical to clearExpiredDebuffs. Removed duplicate.
    isZoneUnlocked: (zoneId) => { // Unchanged from code2
        const zoneConfig = ALL_ZONES_CONFIG.find(z => z.id === zoneId);
        if (!zoneConfig) {
            console.warn(`[useGameStore] isZoneUnlocked: Конфигурация для зоны ${zoneId} не найдена.`);
            return false;
        }
        // The first zone is always unlocked or if no unlock condition is specified
        if (ALL_ZONES_CONFIG[0]?.id === zoneId || !zoneConfig.unlockCondition) {
            return true;
        }

        const { type, requiredZoneId } = zoneConfig.unlockCondition;
        if (type === 'zone_completed') {
            if (!requiredZoneId) {
                console.warn(`[useGameStore] isZoneUnlocked: Для зоны ${zoneId} условие 'zone_completed' не имеет requiredZoneId.`);
                return false; // Or true if missing requirement means unlocked by default? False is safer.
            }
            return !!get().completedZones[requiredZoneId];
        }
        // Add other unlock condition types if needed
        return false;
    },
    completeZone: (zoneId) => { // Unchanged from code2
        const zoneConfig = ALL_ZONES_CONFIG.find(z => z.id === zoneId);
        if (!zoneConfig) {
            console.warn(`[useGameStore] completeZone: Конфигурация для зоны ${zoneId} не найдена.`);
            return;
        }
        if (get().completedZones[zoneId]) {
            // console.log(`[useGameStore] Зона ${zoneConfig.name || zoneId} уже была отмечена как пройденная.`);
            return; // Already completed
        }
        set(state => ({
            completedZones: {
                ...state.completedZones,
                [zoneId]: true,
            }
        }));
        console.log(`[useGameStore] Зона ${zoneConfig.name || zoneId} отмечена как пройденная.`);
        // Potentially trigger achievements or other events for zone completion
        get().checkAllAchievements();
    },
    getLevelCompletionStatus: (chapterId, levelId) => { // Unchanged from code2
        const levelKey = `c${chapterId}_l${levelId}`;
        return get().levelsCompleted[levelKey] || { normal: false, hard: false }; // Return default if not found
    },
    isChapterCompleted: (chapterId, allLevelsInChapter) => { // Unchanged from code2
        if (!allLevelsInChapter || allLevelsInChapter.length === 0) {
            // console.warn(`[isChapterCompleted] No levels provided for chapter ${chapterId}`);
            return false; // Cannot be completed if no levels defined for it
        }
        for (const level of allLevelsInChapter) {
            const levelKey = `c${chapterId}_l${level.id}`;
            const status = get().levelsCompleted[levelKey];
            // Chapter is completed if all its levels are completed on at least normal difficulty
            if (!status || !status.normal) {
                return false; // Found a level not completed on normal
            }
        }
        return true; // All levels completed on normal
    },
    isLevelUnlocked: (chapterId, levelId, allLevelsInChapter, allLevelsInPrevChapter = null, prevChapterId = null) => { // Unchanged from code2
        if (!allLevelsInChapter || allLevelsInChapter.length === 0) return false;

        const levelIndex = allLevelsInChapter.findIndex(l => l.id === levelId);
        if (levelIndex === -1) return false; // Level not found in its chapter's list

        // First level of the very first chapter is always unlocked
        if (chapterId === INITIAL_CHAPTER_ID && levelIndex === 0) {
            return true;
        }

        // For levels other than the first in a chapter: previous level in same chapter must be complete
        if (levelIndex > 0) {
            const prevLevelInChapter = allLevelsInChapter[levelIndex - 1];
            const prevLevelKey = `c${chapterId}_l${prevLevelInChapter.id}`;
            const prevLevelStatus = get().levelsCompleted[prevLevelKey];
            return !!(prevLevelStatus && prevLevelStatus.normal); // Must have completed previous level on normal
        }

        // For the first level of a subsequent chapter: previous chapter must be completed
        if (levelIndex === 0 && chapterId !== INITIAL_CHAPTER_ID) {
            if (allLevelsInPrevChapter && prevChapterId !== null) {
                return get().isChapterCompleted(prevChapterId, allLevelsInPrevChapter);
            }
            // console.warn(`[isLevelUnlocked] Cannot determine unlock status for first level of chapter ${chapterId} without previous chapter data.`);
            return false; // Cannot determine if previous chapter info is missing
        }
        return false; // Default to locked
    },
    isHardModeUnlocked: (chapterId, levelId) => { // Unchanged from code2
        const levelKey = `c${chapterId}_l${levelId}`;
        const status = get().levelsCompleted[levelKey];
        return !!(status && status.normal); // Hard mode unlocked if normal mode is completed
    },
    setIsFullScreenMapActive: (isActive) => { // Unchanged from code2
        set({ isFullScreenMapActive: isActive });
    },
    startScreenTransition: (navigationOrContentChangeCallback, postOpenCallback = null) => { // Unchanged from code2
        if (get().isScreenTransitioning && get().transitionAction === 'closing') {
            // console.log("Transition already closing, new transition ignored or queued.");
            return; // Or implement a queue if needed
        }
        set({
            isScreenTransitioning: true,
            transitionAction: 'closing',
            onTransitionOpenCompleteCallback: null, // Clear any previous open callback
            onTransitionCloseCompleteCallback: () => {
                if (navigationOrContentChangeCallback) {
                    navigationOrContentChangeCallback(); // Execute content change after closing animation
                }
                // Start opening transition
                // Use a minimal timeout to allow React to process the state change from content update
                setTimeout(() => {
                    set({
                        transitionAction: 'opening',
                        onTransitionCloseCompleteCallback: null, // Clear close callback
                        onTransitionOpenCompleteCallback: () => { // Called when opening animation finishes
                            if (postOpenCallback) {
                                postOpenCallback();
                            }
                            set({ // Finalize transition state
                                isScreenTransitioning: false,
                                transitionAction: null,
                                onTransitionOpenCompleteCallback: null
                            });
                        }
                    });
                }, 50); // Small delay for content to render before opening animation
            }
        });
    },
    ensureScreenIsOpening: (postOpenCallback = null) => { // Unchanged from code2
        const state = get();
        // If not transitioning, or if it's stuck in 'closing' (which shouldn't happen with proper flow)
        if (!state.isScreenTransitioning || state.transitionAction !== 'opening') {
            set({
                isScreenTransitioning: true,
                transitionAction: 'opening',
                onTransitionCloseCompleteCallback: null, // Not closing
                onTransitionOpenCompleteCallback: () => {
                    if (postOpenCallback) postOpenCallback();
                    set({
                        isScreenTransitioning: false,
                        transitionAction: null,
                        onTransitionOpenCompleteCallback: null
                    });
                }
            });
        } else if (state.isScreenTransitioning && state.transitionAction === 'opening') {
            // If already opening, perhaps update the callback if needed, or do nothing
            // For simplicity, current implementation doesn't overwrite existing open callback here.
        }
    },
    setCurrentChapter: (chapterId) => { // Unchanged from code2
        set({ currentChapterId: chapterId });
    },
    setHasClaimableRewardsIndicator: (hasRewards) => { // Unchanged from code2
        if (get().hasClaimableRewardsIndicator !== hasRewards) { // Only update if value changed
            set({ hasClaimableRewardsIndicator: hasRewards });
        }
    },
    checkAndResetTreasureChestAttempts: () => set((state) => { // Unchanged from code2
        const nowTs = Date.now();
        const lastResetTs = state.treasureChestLastReset;

        if (!lastResetTs) { // First time or after a full reset
            return { treasureChestAttempts: 3, treasureChestLastReset: nowTs };
        }

        const nowUtcDate = new Date(nowTs);
        // Calculate the timestamp for today's refresh hour in UTC
        let lastRefreshMarkerUtcTs = Date.UTC(
            nowUtcDate.getUTCFullYear(),
            nowUtcDate.getUTCMonth(),
            nowUtcDate.getUTCDate(),
            RUNE_ATTEMPTS_REFRESH_HOUR_UTC, 0, 0, 0 // Using the constant
        );

        // If current time is before today's refresh time, the last refresh point was yesterday
        if (nowTs < lastRefreshMarkerUtcTs) {
            lastRefreshMarkerUtcTs = Date.UTC(
                nowUtcDate.getUTCFullYear(),
                nowUtcDate.getUTCMonth(),
                nowUtcDate.getUTCDate() - 1, // Yesterday
                RUNE_ATTEMPTS_REFRESH_HOUR_UTC, 0, 0, 0
            );
        }

        if (lastResetTs < lastRefreshMarkerUtcTs) { // If last reset was before the most recent refresh point
            return {
                treasureChestAttempts: 3, // Reset to default attempts
                treasureChestLastReset: nowTs // Update last reset time to now
            };
        }
        return {}; // No change needed
    }),
    useTreasureChestAttempt: () => set((state) => { // Unchanged from code2
        if (state.treasureChestAttempts > 0) {
            return { treasureChestAttempts: state.treasureChestAttempts - 1 };
        }
        // console.warn("No treasure chest attempts left.");
        // alert("Нет попыток для сокровищницы!");
        return {}; // No change if no attempts left
    }),
    initializeUserFromTelegram: (tgUserData) => { // Unchanged from code2
        if (tgUserData && tgUserData.photo_url) {
            set({ userPhotoUrl: tgUserData.photo_url });
        } else {
             // Only set to null if it was previously something else, to avoid unnecessary re-renders
            set(state => {
                if (state.userPhotoUrl !== null) {
                    return { userPhotoUrl: null };
                }
                return {};
            });
        }
        // Could also set username here if available and not set:
        // if (tgUserData && tgUserData.username && !get().username) {
        //    set({ username: tgUserData.username });
        // }
    },

    // <<< ACTIONS ИЗ КОД1 ДЛЯ ЗАДАЧ >>>
    // --- Функции сброса (checkAndResetDailyTasks, checkAndResetWeeklyTasks, checkAndResetMonthlyTasks) ---
    // Эти функции используют UTC для определения времени сброса.
    checkAndResetDailyTasks: () => set((state) => {
        console.log(`[TASKS_DEBUG] checkAndResetDailyTasks called at ${new Date().toISOString()}`);
console.log(`[TASKS_DEBUG] Current state before daily check: lastDailyReset=<span class="math-inline">\{new Date\(state\.lastDailyReset\)\.toISOString\(\)\}, dailyLoginToday\=</span>{state.dailyLoginToday}, dailyLoginTaskProgress=${JSON.stringify(state.dailyTaskProgress['ID_ВАШЕЙ_ЗАДАЧИ_НА_ЛОГИН'])}`);
        const nowTs = Date.now();
        const lastResetTs = state.lastDailyReset;

        if (!lastResetTs) { // First ever run or data lost
            const initialProgress = {};
            (ALL_TASK_DEFINITIONS[TASK_TYPES.DAILY] || []).forEach(task => {
                initialProgress[task.id] = { progress: 0, completed: false, claimed: false };
            });
            return {
                dailyTaskProgress: initialProgress, dailyTaskBarXp: 0, dailyBonusClaimed: false,
                lastDailyReset: nowTs, dailyLoginToday: false, killsToday: 0,
                levelsCompletedToday: 0, gearUpgradedToday: 0, chestsOpenedToday: 0,
            };
        }

        const nowUtcDate = new Date(nowTs);
        let lastRefreshMarkerUtcTs = Date.UTC(
            nowUtcDate.getUTCFullYear(), nowUtcDate.getUTCMonth(), nowUtcDate.getUTCDate(),
            DAILY_TASKS_REFRESH_HOUR_UTC, 0, 0, 0
        );

        if (nowTs < lastRefreshMarkerUtcTs) { // If current time is before today's refresh hour
            // Then the relevant refresh marker was yesterday's refresh hour
            const yesterdayUtcDate = new Date(nowTs - 24 * 60 * 60 * 1000); // Approx yesterday
            lastRefreshMarkerUtcTs = Date.UTC(
                yesterdayUtcDate.getUTCFullYear(), yesterdayUtcDate.getUTCMonth(), yesterdayUtcDate.getUTCDate(),
                DAILY_TASKS_REFRESH_HOUR_UTC, 0, 0, 0
            );
        }
        
        if (lastResetTs < lastRefreshMarkerUtcTs) {
            const initialProgress = {};
            (ALL_TASK_DEFINITIONS[TASK_TYPES.DAILY] || []).forEach(task => {
                initialProgress[task.id] = { progress: 0, completed: false, claimed: false };
            });
            return {
                dailyTaskProgress: initialProgress, dailyTaskBarXp: 0, dailyBonusClaimed: false,
                lastDailyReset: nowTs, // Set to current time as it's being reset now
                dailyLoginToday: false, killsToday: 0, levelsCompletedToday: 0,
                gearUpgradedToday: 0, chestsOpenedToday: 0,
            };
        }
        return {}; // No reset needed
    }),

    checkAndResetWeeklyTasks: () => set((state) => {
        const nowTs = Date.now();
        const lastResetTs = state.lastWeeklyReset;

        if (!lastResetTs) {
            const initialProgress = {};
             (ALL_TASK_DEFINITIONS[TASK_TYPES.WEEKLY] || []).forEach(task => {
                initialProgress[task.id] = { progress: 0, completed: false, claimed: false };
            });
            return {
                weeklyTaskProgress: initialProgress, weeklyTaskBarXp: 0, weeklyBonusClaimed: false,
                lastWeeklyReset: nowTs, weeklyLoginDays: 0, killsThisWeek: 0,
                levelsCompletedThisWeek: 0, gearUpgradedThisWeek: 0, chestsOpenedThisWeek: 0,
                lastSeenLoginDateForWeekly: null,
            };
        }

        const nowUtcDate = new Date(nowTs);
        const currentUtcDay = nowUtcDate.getUTCDay(); // 0 (Sun) - 6 (Sat)

        // Calculate days since the last WEEKLY_TASKS_REFRESH_DAY_UTC
        let daysToLastRefreshDay = (currentUtcDay - WEEKLY_TASKS_REFRESH_DAY_UTC + 7) % 7;
        
        const lastRefreshDayDate = new Date(Date.UTC(
            nowUtcDate.getUTCFullYear(),
            nowUtcDate.getUTCMonth(),
            nowUtcDate.getUTCDate() - daysToLastRefreshDay
        ));

        let lastRefreshMarkerUtcTs = Date.UTC(
            lastRefreshDayDate.getUTCFullYear(),
            lastRefreshDayDate.getUTCMonth(),
            lastRefreshDayDate.getUTCDate(),
            WEEKLY_TASKS_REFRESH_HOUR_UTC, 0, 0, 0
        );
        
        // If today IS the refresh day, but the refresh HOUR hasn't passed yet,
        // the marker should be for the *previous* week's refresh day.
        if (currentUtcDay === WEEKLY_TASKS_REFRESH_DAY_UTC && nowTs < lastRefreshMarkerUtcTs) {
            const prevRefreshWeekDate = new Date(Date.UTC(
                nowUtcDate.getUTCFullYear(),
                nowUtcDate.getUTCMonth(),
                nowUtcDate.getUTCDate() - 7 // Go back 7 days
            ));
             lastRefreshMarkerUtcTs = Date.UTC(
                prevRefreshWeekDate.getUTCFullYear(),
                prevRefreshWeekDate.getUTCMonth(),
                prevRefreshWeekDate.getUTCDate(), // This will be the correct refresh day of previous week
                WEEKLY_TASKS_REFRESH_HOUR_UTC, 0, 0, 0
            );
        }


        if (lastResetTs < lastRefreshMarkerUtcTs) {
            const initialProgress = {};
            (ALL_TASK_DEFINITIONS[TASK_TYPES.WEEKLY] || []).forEach(task => {
                initialProgress[task.id] = { progress: 0, completed: false, claimed: false };
            });
            return {
                weeklyTaskProgress: initialProgress, weeklyTaskBarXp: 0, weeklyBonusClaimed: false,
                lastWeeklyReset: nowTs, weeklyLoginDays: 0, killsThisWeek: 0,
                levelsCompletedThisWeek: 0, gearUpgradedThisWeek: 0, chestsOpenedThisWeek: 0,
                lastSeenLoginDateForWeekly: null, // Reset helper for unique weekly logins
            };
        }
        return {};
    }),

    checkAndResetMonthlyTasks: () => set((state) => {
        const nowTs = Date.now();
        const lastResetTs = state.lastMonthlyReset;

        if (!lastResetTs) {
            const initialProgress = {};
            (ALL_TASK_DEFINITIONS[TASK_TYPES.MONTHLY] || []).forEach(task => {
                initialProgress[task.id] = { progress: 0, completed: false, claimed: false };
            });
            return {
                monthlyTaskProgress: initialProgress, monthlyTaskBarXp: 0, monthlyBonusClaimed: false,
                lastMonthlyReset: nowTs, monthlyLoginDays: 0, killsThisMonth: 0,
                levelsCompletedThisMonth: 0, gearUpgradedThisMonth: 0, chestsOpenedThisMonth: 0,
                lastSeenLoginDateForMonthly: null,
            };
        }

        const nowUtcDate = new Date(nowTs);
        // Marker for this month's refresh day and hour
        let currentMonthRefreshMarkerUtcTs = Date.UTC(
            nowUtcDate.getUTCFullYear(),
            nowUtcDate.getUTCMonth(), // Current month
            MONTHLY_TASKS_REFRESH_DAY_OF_MONTH_UTC,
            MONTHLY_TASKS_REFRESH_HOUR_UTC, 0, 0, 0
        );

        let lastRefreshMarkerUtcTs;
        // If current time is past or at this month's refresh time
        if (nowTs >= currentMonthRefreshMarkerUtcTs) {
            lastRefreshMarkerUtcTs = currentMonthRefreshMarkerUtcTs;
        } else {
            // If current time is before this month's refresh time, the marker was last month's refresh
            const prevMonthDate = new Date(Date.UTC(nowUtcDate.getUTCFullYear(), nowUtcDate.getUTCMonth() -1, 1)); // Get first day of previous month
            lastRefreshMarkerUtcTs = Date.UTC(
                prevMonthDate.getUTCFullYear(),
                prevMonthDate.getUTCMonth(),
                MONTHLY_TASKS_REFRESH_DAY_OF_MONTH_UTC,
                MONTHLY_TASKS_REFRESH_HOUR_UTC, 0, 0, 0
            );
        }

        if (lastResetTs < lastRefreshMarkerUtcTs) {
            const initialProgress = {};
             (ALL_TASK_DEFINITIONS[TASK_TYPES.MONTHLY] || []).forEach(task => {
                initialProgress[task.id] = { progress: 0, completed: false, claimed: false };
            });
            return {
                monthlyTaskProgress: initialProgress, monthlyTaskBarXp: 0, monthlyBonusClaimed: false,
                lastMonthlyReset: nowTs, monthlyLoginDays: 0, killsThisMonth: 0,
                levelsCompletedThisMonth: 0, gearUpgradedThisMonth: 0, chestsOpenedThisMonth: 0,
                lastSeenLoginDateForMonthly: null, // Reset helper for unique monthly logins
            };
        }
        return {};
    }),

    // === НОВЫЙ УНИВЕРСАЛЬНЫЙ ACTION: ОТСЛЕЖИВАНИЕ ИГРОВЫХ СОБЫТИЙ ДЛЯ ЗАДАНИЙ ===
    // This action is implemented as per code1.
    // It has an internal logical inconsistency regarding how `eventType` relates to `taskDef.eventTracked`.
    // For it to work as written, taskDef.eventTracked must often be the same as eventType,
    // and the eventType passed would need to be specific (e.g., 'killsToday' not 'kill_monster').
    // The first switch handles 'raw' events to update counters.
    // The second part (task loop) uses `if (taskDef.eventTracked === eventType)` which is the point of conflict.
// --- Начало методов вашего хранилища (store) ---
trackTaskEvent: (eventType, amount = 1) => {
    console.log(`[Tasks] Track Event: ${eventType}, Amount: ${amount}`);
    const state = get(); // Получаем текущее состояние в начале
    let counterChanges = {}; // Для атомарного обновления счетчиков
    const now = new Date();
    const todayDateString = now.toISOString().split('T')[0]; // YYYY-MM-DD формат из код1

    // --- 1. Обновляем периодические счетчики событий (логика из код1) ---
    switch (eventType) {
        case 'login':
            if (!state.dailyLoginToday) {
                counterChanges.dailyLoginToday = true;
                console.log("[Tasks] Daily login marked for task system.");
            }
            // Точное отслеживание уникальных дней для недельных/месячных логинов из код1
            if (state.lastLoginDateForWeekly !== todayDateString) {
                counterChanges.weeklyLoginDays = (state.weeklyLoginDays || 0) + 1;
                counterChanges.lastLoginDateForWeekly = todayDateString;
                // В консоль выводим значение из counterChanges, если оно там есть, иначе из state + 1
                console.log("[Tasks] Weekly login day incremented. Current: ", counterChanges.weeklyLoginDays || (state.weeklyLoginDays || 0) + 1);
            }
            if (state.lastLoginDateForMonthly !== todayDateString) {
                counterChanges.monthlyLoginDays = (state.monthlyLoginDays || 0) + 1;
                counterChanges.lastLoginDateForMonthly = todayDateString;
                console.log("[Tasks] Monthly login day incremented. Current: ", counterChanges.monthlyLoginDays || (state.monthlyLoginDays || 0) + 1);
            }
            break;
        case 'kill_monster':
            counterChanges.killsToday = (state.killsToday || 0) + amount;
            counterChanges.killsThisWeek = (state.killsThisWeek || 0) + amount;
            counterChanges.killsThisMonth = (state.killsThisMonth || 0) + amount;
            break;
        case 'complete_level':
            counterChanges.levelsCompletedToday = (state.levelsCompletedToday || 0) + amount;
            counterChanges.levelsCompletedThisWeek = (state.levelsCompletedThisWeek || 0) + amount;
            counterChanges.levelsCompletedThisMonth = (state.levelsCompletedThisMonth || 0) + amount;
            break;
        case 'upgrade_gear':
            counterChanges.gearUpgradedToday = (state.gearUpgradedToday || 0) + amount;
            counterChanges.gearUpgradedThisWeek = (state.gearUpgradedThisWeek || 0) + amount;
            counterChanges.gearUpgradedThisMonth = (state.gearUpgradedThisMonth || 0) + amount;
            break;
        case 'open_chest':
            counterChanges.chestsOpenedToday = (state.chestsOpenedToday || 0) + amount;
            counterChanges.chestsOpenedThisWeek = (state.chestsOpenedThisWeek || 0) + amount;
            counterChanges.chestsOpenedThisMonth = (state.chestsOpenedThisMonth || 0) + amount;
            break;
        default:
            break;
    }
    
    if (Object.keys(counterChanges).length > 0) {
        set(counterChanges); // Применяем изменения счетчиков
    }
    
    // --- 2. Обновляем прогресс самих заданий (логика из код1) ---
    const updatedState = get(); // Получаем состояние с обновленными счетчиками
    let newDailyProgress = { ...updatedState.dailyTaskProgress };
    let newWeeklyProgress = { ...updatedState.weeklyTaskProgress };
    let newMonthlyProgress = { ...updatedState.monthlyTaskProgress };
    let anyTaskProgressChanged = false;

    const taskProcessingLogic = (taskDef, progressObject, taskType) => {
        const taskState = progressObject[taskDef.id] || { progress: 0, completed: false, claimed: false, initialStatValue: 0 };
        
        if (taskState.completed) return false;

        let currentEventValueForTask = 0;
        let taskAffectedByThisEvent = false;

        if (
            (eventType === 'login' && (taskDef.eventTracked === 'dailyLoginToday' || taskDef.eventTracked === 'weeklyLoginDays' || taskDef.eventTracked === 'monthlyLoginDays')) ||
            (eventType === 'kill_monster' && (taskDef.eventTracked === 'killsToday' || taskDef.eventTracked === 'killsThisWeek' || taskDef.eventTracked === 'killsThisMonth' || taskDef.eventTracked === 'totalKills')) ||
            (eventType === 'complete_level' && (taskDef.eventTracked === 'levelsCompletedToday' || taskDef.eventTracked === 'levelsCompletedThisWeek' || taskDef.eventTracked === 'levelsCompletedThisMonth')) ||
            (eventType === 'upgrade_gear' && (taskDef.eventTracked === 'gearUpgradedToday' || taskDef.eventTracked === 'gearUpgradedThisWeek' || taskDef.eventTracked === 'gearUpgradedThisMonth')) ||
            (eventType === 'open_chest' && (taskDef.eventTracked === 'chestsOpenedToday' || taskDef.eventTracked === 'chestsOpenedThisWeek' || taskDef.eventTracked === 'chestsOpenedThisMonth')) ||
            (updatedState.hasOwnProperty(taskDef.eventTracked) && taskDef.eventTracked === eventType)
        ) {
            taskAffectedByThisEvent = true;
            
            if (updatedState.hasOwnProperty(taskDef.eventTracked)) {
                if (taskDef.eventTracked === 'dailyLoginToday') {
                    currentEventValueForTask = updatedState.dailyLoginToday ? 1 : 0;
                } else if (taskDef.statResetType) { 
                    currentEventValueForTask = updatedState[taskDef.eventTracked] || 0;
                } else { 
                    currentEventValueForTask = updatedState[taskDef.eventTracked] || 0;
                }
            }
        }

        if (taskAffectedByThisEvent) {
            currentEventValueForTask = Number(currentEventValueForTask) || 0;
            const newProgress = Math.min(currentEventValueForTask, taskDef.target);

            if (newProgress !== taskState.progress || (newProgress >= taskDef.target && !taskState.completed)) {
                progressObject[taskDef.id] = { 
                    ...taskState, 
                    progress: newProgress,
                    completed: newProgress >= taskDef.target 
                };
                if (progressObject[taskDef.id].completed && !taskState.completed) {
                     console.log(`[Tasks] ${taskType} task '${taskDef.id}' COMPLETED! Value: ${currentEventValueForTask}, Target: ${taskDef.target}`);
                }
                return true;
            }
        }
        return false;
    };
    
    [TASK_TYPES.DAILY, TASK_TYPES.WEEKLY, TASK_TYPES.MONTHLY].forEach(taskType => {
        const definitions = ALL_TASK_DEFINITIONS[taskType] || [];
        let progressMap;
        if (taskType === TASK_TYPES.DAILY) progressMap = newDailyProgress;
        else if (taskType === TASK_TYPES.WEEKLY) progressMap = newWeeklyProgress;
        else if (taskType === TASK_TYPES.MONTHLY) progressMap = newMonthlyProgress;
        else return;

        definitions.forEach(taskDef => {
            if (taskDef.eventTracked) {
                 if (taskProcessingLogic(taskDef, progressMap, taskType)) {
                    anyTaskProgressChanged = true;
                }
            }
        });
    });

    if (anyTaskProgressChanged) {
        set({ 
            dailyTaskProgress: newDailyProgress,
            weeklyTaskProgress: newWeeklyProgress,
            monthlyTaskProgress: newMonthlyProgress,
        });
        // После обновления прогресса задач, также проверяем индикатор наград
        get().setHasClaimableRewardsIndicator(get().checkIfAnyTaskOrAchievementIsClaimable());
    }
},

claimTaskReward: (taskType, taskId) => {
    const state = get();
    let progressObjectKey, taskBarXpKey, taskDefinitionsForType;
    let changesToSet = {};

    if (taskType === TASK_TYPES.DAILY) {
        progressObjectKey = 'dailyTaskProgress';
        taskBarXpKey = 'dailyTaskBarXp';
        taskDefinitionsForType = ALL_TASK_DEFINITIONS[TASK_TYPES.DAILY];
    } else if (taskType === TASK_TYPES.WEEKLY) {
        progressObjectKey = 'weeklyTaskProgress';
        taskBarXpKey = 'weeklyTaskBarXp';
        taskDefinitionsForType = ALL_TASK_DEFINITIONS[TASK_TYPES.WEEKLY];
    } else if (taskType === TASK_TYPES.MONTHLY) {
        progressObjectKey = 'monthlyTaskProgress';
        taskBarXpKey = 'monthlyTaskBarXp';
        taskDefinitionsForType = ALL_TASK_DEFINITIONS[TASK_TYPES.MONTHLY];
    } else {
        console.error(`[Tasks] Unknown taskType for claim: ${taskType}`);
        return;
    }

    const currentTaskProgressMap = state[progressObjectKey];
    const taskState = currentTaskProgressMap ? currentTaskProgressMap[taskId] : null;
    const taskDef = taskDefinitionsForType ? taskDefinitionsForType.find(t => t.id === taskId) : null;

    if (taskState && taskDef && taskState.completed && !taskState.claimed) {
        console.log(`[Tasks] Claiming reward for ${taskType} task: ${taskId}`);
        
        if (taskDef.reward) {
            if (taskDef.reward.diamonds) {
                get().addDiamonds(taskDef.reward.diamonds);
            }
            if (taskDef.reward.gold) {
                get().addGold(taskDef.reward.gold);
            }
            // if (taskDef.reward.type === 'item' && taskDef.reward.itemId) {
            //   get().addItemToInventory(taskDef.reward.itemId, taskDef.reward.quantity || 1);
            // }
        }

        const newProgressMap = { 
            ...state[progressObjectKey], 
            [taskId]: { ...taskState, claimed: true } 
        };
        changesToSet[progressObjectKey] = newProgressMap;

        const newXp = (state[taskBarXpKey] || 0) + (taskDef.xp || 0);
        changesToSet[taskBarXpKey] = newXp;
        
        if (Object.keys(changesToSet).length > 0) {
            set(changesToSet);
        }
        
        get().checkAllAchievements(); 
        get().setHasClaimableRewardsIndicator(get().checkIfAnyTaskOrAchievementIsClaimable());
    }
},

claimBonusReward: (taskType) => {
    const state = get();
    const bonusConfig = BONUS_REWARDS_CONFIG[taskType]; 
    if (!bonusConfig) { 
        console.error(`[Tasks] No bonus config for taskType: ${taskType}`); 
        return; 
    }

    let taskBarXpKey, bonusClaimedKey;
    if (taskType === TASK_TYPES.DAILY) {
        taskBarXpKey = 'dailyTaskBarXp';
        bonusClaimedKey = 'dailyBonusClaimed';
    } else if (taskType === TASK_TYPES.WEEKLY) {
        taskBarXpKey = 'weeklyTaskBarXp';
        bonusClaimedKey = 'weeklyBonusClaimed';
    } else if (taskType === TASK_TYPES.MONTHLY) {
        taskBarXpKey = 'monthlyTaskBarXp';
        bonusClaimedKey = 'monthlyBonusClaimed';
    } else {
        console.error(`[Tasks] Unknown taskType for bonus reward: ${taskType}`);
        return;
    }

    let changesToSet = {};

    if ((state[taskBarXpKey] || 0) >= bonusConfig.xpRequired && !state[bonusClaimedKey]) {
        console.log(`[Tasks] Claiming BONUS reward for ${taskType} tasks!`);
        const reward = bonusConfig.reward;
        
        if (reward.type === 'item_key' && reward.itemId) {
            // get().addItemToInventory(reward.itemId, reward.quantity || 1);
            console.warn(`[Tasks] Bonus item_key: ${reward.name || reward.itemId} x${reward.quantity || 1}. Implement item/key adding via store action.`);
        } else if (reward.type === 'currency' && reward.currencyId) {
            if (reward.currencyId === 'diamonds') {
                get().addDiamonds(reward.quantity);
            } else if (reward.currencyId === 'gold') {
                get().addGold(reward.quantity);
            } else if (reward.currencyId === 'toncoin_shards') {
                // get().addTonShards(reward.quantity);
                console.warn(`[Tasks] Bonus currency: ${reward.name || reward.currencyId} x${reward.quantity}. Implement TON shard adding via store action.`);
            }
        }

        changesToSet[bonusClaimedKey] = true;
        set(changesToSet);

        get().checkAllAchievements();
        get().setHasClaimableRewardsIndicator(get().checkIfAnyTaskOrAchievementIsClaimable());
    }
},

// Helper to check if any task or achievement is claimable (for the indicator)
// Это ваша функция, как вы ее предоставили
checkIfAnyTaskOrAchievementIsClaimable: () => {
    const state = get();
    // Check tasks
    const taskTypes = [TASK_TYPES.DAILY, TASK_TYPES.WEEKLY, TASK_TYPES.MONTHLY];
    for (const taskType of taskTypes) {
        // ВАЖНО: Убедитесь, что TASK_TYPES.DAILY и т.д. соответствуют ключам в state,
        // например, 'daily', 'weekly', 'monthly'
        const progressKey = `${taskType}TaskProgress`; // например, 'dailyTaskProgress'
        const taskProgressMap = state[progressKey];
        if (taskProgressMap) {
            for (const taskId in taskProgressMap) {
                if (taskProgressMap[taskId].completed && !taskProgressMap[taskId].claimed) {
                    return true;
                }
            }
        }
        // Check bonus
        const bonusConfig = BONUS_REWARDS_CONFIG[taskType];
        if (bonusConfig) {
            const xpKey = `${taskType}TaskBarXp`; // например, 'dailyTaskBarXp'
            const claimedKey = `${taskType}BonusClaimed`; // например, 'dailyBonusClaimed'
            if ((state[xpKey] || 0) >= bonusConfig.xpRequired && !state[claimedKey]) {
                return true;
            }
        }
    }
    // Check achievements (from existing logic in checkAllAchievements or similar)
    // achievementsData должна быть доступна (например, импортирована или из state)
    if (state.achievementsData && Array.isArray(state.achievementsData)) { // Пример, если achievementsData в state
        for (const achDef of state.achievementsData) { // или просто achievementsData, если это импортированная константа
            const status = state.achievementsStatus[achDef.id] || { completed: false, claimed: false };
            if (status.completed && !status.claimed) {
                return true;
            }
        }
    } else if (typeof achievementsData !== 'undefined' && Array.isArray(achievementsData)) { // Если это глобальная/импортированная константа
         for (const achDef of achievementsData) {
            const status = state.achievementsStatus[achDef.id] || { completed: false, claimed: false };
            if (status.completed && !status.claimed) {
                return true;
            }
        }
    }

    return false;
}

})); // Конец create

// ================== Сохранение в localStorage (ОБЪЕДИНЕНО С КОД1) ==================
useGameStore.subscribe((state) => {
    const {
        gold, diamonds, username, inventory, equipped, powerLevel,
        playerBaseStats, playerHp, playerRace,
        energyCurrent, energyMax, lastEnergyRefillTimestamp,
        dailyDeals, dailyDealsLastGenerated, dailyShopPurchases,
        achievementsStatus, totalGoldCollected, totalKills,
        booleanFlags, levelsCompleted,
        achievementLevel, achievementXp,
        artifactChestPity, gearKeys, totalArtifactChestsOpened,
        collectedArtifacts, artifactLevels,
        gearChestPity, totalGearChestsOpened,
        activeDebuffs,
        treasureChestAttempts, treasureChestLastReset,
        userPhotoUrl, currentChapterId, completedZones, isAffectedByWeakeningAura,
        levelChestStates, // Added from state

        // <<< Поля для задач из КОД1 >>>
        dailyTaskProgress, dailyTaskBarXp, dailyBonusClaimed, lastDailyReset,
        dailyLoginToday, killsToday, levelsCompletedToday, gearUpgradedToday, chestsOpenedToday,
        lastSeenLoginDateForWeekly, lastSeenLoginDateForMonthly,
        weeklyTaskProgress, weeklyTaskBarXp, weeklyBonusClaimed, lastWeeklyReset,
        weeklyLoginDays, killsThisWeek, levelsCompletedThisWeek, gearUpgradedThisWeek, chestsOpenedThisWeek,
        monthlyTaskProgress, monthlyTaskBarXp, monthlyBonusClaimed, lastMonthlyReset,
        monthlyLoginDays, killsThisMonth, levelsCompletedThisMonth, gearUpgradedThisMonth, chestsOpenedThisMonth,
    } = state;

    const stateToSave = {
        gold, diamonds, username, inventory, equipped, powerLevel,
        playerBaseStats, playerHp, playerRace,
        energyCurrent, energyMax, lastEnergyRefillTimestamp,
        dailyDeals, dailyDealsLastGenerated, dailyShopPurchases,
        achievementsStatus, totalGoldCollected, totalKills,
        booleanFlags, levelsCompleted,
        achievementLevel, achievementXp,
        collectedArtifacts: Array.from(collectedArtifacts), // Convert Set to Array for JSON
        artifactLevels, artifactChestPity, gearKeys, totalArtifactChestsOpened,
        gearChestPity, totalGearChestsOpened,
        activeDebuffs,
        treasureChestAttempts, treasureChestLastReset,
        userPhotoUrl, currentChapterId, completedZones, isAffectedByWeakeningAura,
        levelChestStates,

        // <<< Поля для задач из КОД1 >>>
        dailyTaskProgress, dailyTaskBarXp, dailyBonusClaimed, lastDailyReset,
        dailyLoginToday, killsToday, levelsCompletedToday, gearUpgradedToday, chestsOpenedToday,
        lastSeenLoginDateForWeekly, lastSeenLoginDateForMonthly,
        weeklyTaskProgress, weeklyTaskBarXp, weeklyBonusClaimed, lastWeeklyReset,
        weeklyLoginDays, killsThisWeek, levelsCompletedThisWeek, gearUpgradedThisWeek, chestsOpenedThisWeek,
        monthlyTaskProgress, monthlyTaskBarXp, monthlyBonusClaimed, lastMonthlyReset,
        monthlyLoginDays, killsThisMonth, levelsCompletedThisMonth, gearUpgradedThisMonth, chestsOpenedThisMonth,
    };

    try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(stateToSave));
    } catch (error) {
        console.error("Ошибка сохранения состояния в localStorage:", error);
    }
});

// Interval for clearing expired debuffs (from code2)
setInterval(() => {
    useGameStore.getState().clearExpiredDebuffs();
}, 5000); // Every 5 seconds

// Initial checks for task resets and daily deals (can also be done in App.js useEffect)
// Wrapped in a timeout to ensure store is fully initialized
setTimeout(() => {
    console.log("Performing initial checks for tasks and deals...");
    useGameStore.getState().checkAndResetDailyTasks();
    useGameStore.getState().checkAndResetWeeklyTasks();
    useGameStore.getState().checkAndResetMonthlyTasks();
    useGameStore.getState().checkAndRefreshDailyDeals();
    useGameStore.getState().checkAndResetTreasureChestAttempts();
    useGameStore.getState().refillEnergyOnLoad(); // Refill offline energy
    useGameStore.getState().checkAllAchievements(); // Initial check for achievements status
    // Initial check for claimable rewards indicator
    useGameStore.getState().setHasClaimableRewardsIndicator(
        useGameStore.getState().checkIfAnyTaskOrAchievementIsClaimable()
    );

}, 100); // Delay a bit to ensure store is ready

export default useGameStore;