// src/store/useGameStore.js
import { create } from "zustand";
import itemsDatabase, { getItemById } from '../data/itemsDatabase';
import { LEVEL_CHEST_TYPES, getLevelChestTypeById } from '../data/levelChestData';
import forgeRecipes from "../data/forgeDatabase";
// import { dailyShopDeals } from "../data/shopData"; // Assuming this is for example, as dailyDeals generated by store in code2
import achievementsData from '../data/achievementsDatabase';
import { RACES, getRaceDataById } from '../config/raceData';
import { ALL_ZONES_CONFIG } from '../data/worldMapData';

import {
    ALL_TASK_DEFINITIONS,
    TASK_TYPES,
    BONUS_REWARDS_CONFIG,
} from '../data/tasksData';

import {
    ARTIFACT_SETS,
    getArtifactById,
    MAX_ARTIFACT_LEVEL,
    BASE_SHARD_COST_PER_LEVEL,
    ALL_ARTIFACTS_ARRAY
} from '../data/artifactsData';
import { getArtifactChestById, selectWeightedRandom as selectWeightedRewardType } from '../data/artifactChestData.js';
import { GEAR_CHESTS, getGearChestById } from '../data/gearChestData';
import { v4 as uuidv4 } from 'uuid';

// --- ШАРДПАСС ИМПОРТЫ (из КОД1) ---
import { MOCK_SHARD_PASS_DATA_FULL as shardPassSeasonDefinitions } from '../data/ShardPassRewardsData'; // Определения наград
import { initialTasksData as shardPassTaskDefinitionsByWeek, SHARD_PASS_TASKS_WEEKS } from '../data/ShardPassTasksData'; // Определения заданий
import { SEASON_START_DATE_UTC, getUnlockDateTimeForWeek } from '../data/TimeConstants'; // Для управления неделями

const STORAGE_KEY = "gameState";
const ENERGY_REFILL_INTERVAL_MS = 30 * 60 * 1000; // 30 минут
const DEFAULT_MAX_ENERGY = 30;
export const TON_SHARD_TO_TON_EXCHANGE_RATE = 10;

const ACHIEVEMENT_LEVEL_XP_THRESHOLDS = { 1: 0, 2: 100, 3: 250, 4: 500, 5: 1000 };
export const ACHIEVEMENT_LEVEL_REWARDS = {
    2: { gold: 50, diamonds: 5 }, 3: { gold: 100, diamonds: 10 },
    4: { gold: 200, diamonds: 15 }, 5: { gold: 500, diamonds: 25 }
};
const getXpNeededForLevel = (level) => ACHIEVEMENT_LEVEL_XP_THRESHOLDS[level + 1] ?? Infinity;

const DEFAULT_BASE_STATS = { hp: 100, attack: 10, attackSpeed: 1.0, critChance: 5, doubleStrikeChance: 0, speed: 5, range: 3, skin: 'default', defense: 0, hpRegen: 0, evasion: 0, maxMana: 0, elementalDmgPercent: 0, goldFind: 0, luck: 0, bossDmg: 0, shardFind: 0, bonusProjectiles: 0, atkPercentBonus: 0, moveSpeedPercentBonus: 0 };

const REFRESH_HOUR_UTC = 2;
const DAILY_TASKS_REFRESH_HOUR_UTC = REFRESH_HOUR_UTC;
const WEEKLY_TASKS_REFRESH_DAY_UTC = 1;
const WEEKLY_TASKS_REFRESH_HOUR_UTC = REFRESH_HOUR_UTC;
const MONTHLY_TASKS_REFRESH_DAY_OF_MONTH_UTC = 1;
const MONTHLY_TASKS_REFRESH_HOUR_UTC = REFRESH_HOUR_UTC;
const RUNE_ATTEMPTS_REFRESH_HOUR_UTC = REFRESH_HOUR_UTC;

const INITIAL_CHAPTER_ID = 1;

// --- Начальное состояние для ShardPass (из КОД1) ---
const getDefaultShardPassState = () => {
    const initialRewardsClaimed = {};
    shardPassSeasonDefinitions.levels.forEach(level => {
        if (level.freeReward) initialRewardsClaimed[`level_${level.level}_free`] = false;
        if (level.premiumReward) initialRewardsClaimed[`level_${level.level}_premium`] = false;
    });

    const initialTaskProgress = {};
    Object.keys(shardPassTaskDefinitionsByWeek).forEach(weekKey => {
        initialTaskProgress[weekKey] = {};
        shardPassTaskDefinitionsByWeek[weekKey].forEach(taskDef => {
            const taskInitialState = {
                progress: 0,
                isClaimed: false,
            };
            if (taskDef.eventTracked === 'login') { // Проверяем тип задачи
                taskInitialState.lastCountedLoginDate = null; // Инициализируем поле для задач на логин
            }
            initialTaskProgress[weekKey][taskDef.id] = taskInitialState;
        });
    });

    return {
        shardPassSeasonId: shardPassSeasonDefinitions.seasonId || `season_${shardPassSeasonDefinitions.seasonNumber}_default`,
        shardPassCurrentLevel: shardPassSeasonDefinitions.defaultStartLevel || 1,
        shardPassCurrentXp: 0,
        shardPassXpPerLevel: shardPassSeasonDefinitions.xpPerLevel || 1000,
        shardPassMaxLevel: shardPassSeasonDefinitions.maxLevel || 50,
        isShardPassPremium: false,
        shardPassRewardsClaimed: initialRewardsClaimed,
        shardPassTasksProgress: initialTaskProgress,
        shardPassSeasonStartDateUTC: SEASON_START_DATE_UTC.toISOString(),
    };
};

const createItemInstance = (itemTemplate) => {
    if (!itemTemplate) {
        console.warn("Attempted to create instance from null/undefined template");
        return null;
    }
    return { ...itemTemplate, uid: uuidv4(), currentLevel: 0 };
};

const getDefaultEquippedSet = () => {
    const defaultSet = { weapon: null, amulet: null, ring: null, helmet: null, armor: null, boots: null };
    const types = Object.keys(defaultSet);

    types.forEach(type => {
        const commonItemTemplate = itemsDatabase.find(
            item => item.type === type && item.rarity === 'Common'
        );
        defaultSet[type] = commonItemTemplate ? createItemInstance(commonItemTemplate) : null;
    });
     const missing = types.filter(type => defaultSet[type] === null);
     if (missing.length > 0) {
         console.warn(`Could not find default Common items for types: ${missing.join(', ')}`);
     }
    return defaultSet;
};


// --- Функция Загрузки состояния из localStorage (ОБЪЕДИНЕНА КОД1 и КОД2) ---
const loadFromLocalStorage = () => {
    try {
        const saved = localStorage.getItem(STORAGE_KEY);

        const defaultStateForTasks = { // из КОД2, используется в КОД1
            dailyTaskProgress: {}, dailyTaskBarXp: 0, dailyBonusClaimed: false, lastDailyReset: null,
            dailyLoginToday: false, killsToday: 0, levelsCompletedToday: 0, gearUpgradedToday: 0, chestsOpenedToday: 0,
            lastSeenLoginDateForWeekly: null,
            lastSeenLoginDateForMonthly: null,
            weeklyTaskProgress: {}, weeklyTaskBarXp: 0, weeklyBonusClaimed: false, lastWeeklyReset: null,
            weeklyLoginDays: 0, killsThisWeek: 0, levelsCompletedThisWeek: 0, gearUpgradedThisWeek: 0, chestsOpenedThisWeek: 0,
            monthlyTaskProgress: {}, monthlyTaskBarXp: 0, monthlyBonusClaimed: false, lastMonthlyReset: null,
            monthlyLoginDays: 0, killsThisMonth: 0, levelsCompletedThisMonth: 0, gearUpgradedThisMonth: 0, chestsOpenedThisMonth: 0,
        };
        const defaultShardPass = getDefaultShardPassState(); // из КОД1

        if (!saved) {
            console.log("No saved state. Initializing with defaults, tasks and ShardPass.");
            return {
                equipped: getDefaultEquippedSet(),
                collectedArtifacts: new Set(),
                gold: 100000, diamonds: 10000,
                toncoinShards: 0, toncoinBalance: 0,
                username: null, powerLevel: 0,
                playerBaseStats: { ...DEFAULT_BASE_STATS },
                playerHp: DEFAULT_BASE_STATS.hp,
                playerRace: null,
                inventory: [],
                energyMax: DEFAULT_MAX_ENERGY, energyCurrent: DEFAULT_MAX_ENERGY,
                lastEnergyRefillTimestamp: Date.now(),
                dailyShopPurchases: {}, achievementsStatus: {},
                totalGoldCollected: 0, totalKills: 0,
                booleanFlags: {}, levelsCompleted: {},
                achievementLevel: 1, achievementXp: 0,
                artifactLevels: {}, artifactChestPity: {},
                gearKeys: 0, totalArtifactChestsOpened: 0,
                gearChestPity: {}, totalGearChestsOpened: 0,
                dailyDeals: [], dailyDealsLastGenerated: null,
                lastOpenedChestInfo: null, lastChestRewards: null,
                treasureChestAttempts: 3, treasureChestLastReset: null,
                activeDebuffs: [], completedZones: {},
                isAffectedByWeakeningAura: false, userPhotoUrl: null,
                currentChapterId: INITIAL_CHAPTER_ID,
                levelChestStates: {}, // из КОД2
                ...defaultStateForTasks,
                ...defaultShardPass, // Добавляем дефолты для ShardPass (из КОД1)
            };
        }

        let parsed = JSON.parse(saved);
        console.log("Saved state found. Processing...");

        // Migration for playerBaseStats (из КОД2)
        if (parsed && parsed.playerBaseStats && (parsed.playerBaseStats.defense !== undefined || parsed.playerBaseStats.health !== undefined)) {
            console.log("Миграция старых playerBaseStats...");
            let updatedStats = { ...parsed.playerBaseStats };
            delete updatedStats.defense;
            if (updatedStats.health !== undefined) { updatedStats.hp = updatedStats.health; delete updatedStats.health; }
            Object.keys(DEFAULT_BASE_STATS).forEach(key => { updatedStats[key] = updatedStats[key] ?? DEFAULT_BASE_STATS[key]; });
            parsed.playerBaseStats = updatedStats;
            console.log("Миграция playerBaseStats завершена.");
        }

        const defaultFullStateForNewKeys = { // Объединенный из КОД1 и КОД2
            equipped: getDefaultEquippedSet(), collectedArtifacts: new Set(), gold: 0, diamonds: 0,
            toncoinShards: 0, toncoinBalance: 0, username: null, powerLevel: 0,
            playerBaseStats: { ...DEFAULT_BASE_STATS }, playerHp: DEFAULT_BASE_STATS.hp, playerRace: null,
            inventory: [], energyMax: DEFAULT_MAX_ENERGY, energyCurrent: DEFAULT_MAX_ENERGY,
            lastEnergyRefillTimestamp: Date.now(), dailyShopPurchases: {}, achievementsStatus: {},
            totalGoldCollected: 0, totalKills: 0, booleanFlags: {}, levelsCompleted: {},
            achievementLevel: 1, achievementXp: 0, artifactLevels: {}, artifactChestPity: {},
            gearKeys: 0, totalArtifactChestsOpened: 0, gearChestPity: {}, totalGearChestsOpened: 0,
            dailyDeals: [], dailyDealsLastGenerated: null, lastOpenedChestInfo: null, lastChestRewards: null,
            treasureChestAttempts: 3, treasureChestLastReset: null, activeDebuffs: [],
            isAffectedByWeakeningAura: false, completedZones: {}, userPhotoUrl: null,
            currentChapterId: INITIAL_CHAPTER_ID,
            levelChestStates: {}, // из КОД2, было неявно в КОД1
            ...defaultStateForTasks,
            ...defaultShardPass, // Для проверки новых ключей ShardPass (из КОД1)
        };

        for (const key in defaultFullStateForNewKeys) {
            if (parsed[key] === undefined) {
                if (key === 'collectedArtifacts') parsed[key] = new Set();
                else if (key === 'equipped' && defaultFullStateForNewKeys[key] === null) parsed[key] = getDefaultEquippedSet();
                else parsed[key] = defaultFullStateForNewKeys[key];
            }
        }
        
        // Ensure equipped is valid or reset (из КОД2)
        const savedEquipped = parsed.equipped;
        const isSavedEquippedInvalid = !savedEquipped || typeof savedEquipped !== 'object' || Object.keys(savedEquipped).length !== 6 || Object.values(savedEquipped).some(v => v === undefined);

        if (isSavedEquippedInvalid) {
            console.warn("Saved 'equipped' state is missing, invalid, or has undefined slots. Initializing with default Common set.");
            parsed.equipped = getDefaultEquippedSet();
        } else {
            let needsFix = false;
            for (const slot in parsed.equipped) {
                if (parsed.equipped[slot] === undefined) {
                    needsFix = true;
                    break;
                }
            }
            if (needsFix) {
                 console.warn("Some slots in 'equipped' were undefined. Resetting to default Common set.");
                 parsed.equipped = getDefaultEquippedSet();
            }
        }

        if (parsed.toncoinBalance === undefined) { // из КОД2
            parsed.toncoinBalance = 0;
        }
        // Этот цикл уже был выше, но в КОД2 был специфичный для toncoinBalance, оставим общую логику из КОД1
        // for (const key in defaultFullStateForNewKeys) { ... }

        if (parsed.collectedArtifacts && !(parsed.collectedArtifacts instanceof Set)) {
            try {
                parsed.collectedArtifacts = new Set(parsed.collectedArtifacts);
            } catch (e) {
                console.error("Failed to reconstruct Set for collectedArtifacts, resetting.", e);
                parsed.collectedArtifacts = new Set();
            }
        }

        // Убедимся, что структуры ShardPass инициализированы (из КОД1)
        if (!parsed.shardPassSeasonId || typeof parsed.shardPassRewardsClaimed !== 'object' || typeof parsed.shardPassTasksProgress !== 'object') {
            console.warn("ShardPass data missing or malformed in saved state, re-initializing ShardPass part.");
            const defaultSP = getDefaultShardPassState();
            parsed.shardPassSeasonId = defaultSP.shardPassSeasonId;
            parsed.shardPassCurrentLevel = defaultSP.shardPassCurrentLevel;
            parsed.shardPassCurrentXp = defaultSP.shardPassCurrentXp;
            parsed.shardPassXpPerLevel = defaultSP.shardPassXpPerLevel;
            parsed.shardPassMaxLevel = defaultSP.shardPassMaxLevel;
            parsed.isShardPassPremium = parsed.isShardPassPremium || false; // Сохраняем, если уже было куплено
            parsed.shardPassRewardsClaimed = defaultSP.shardPassRewardsClaimed;
            parsed.shardPassTasksProgress = defaultSP.shardPassTasksProgress;
            parsed.shardPassSeasonStartDateUTC = defaultSP.shardPassSeasonStartDateUTC;
        }
        // Ensure other new fields from defaultStateForTasks are present (из КОД2, но покрывается общим циклом выше)
        for (const key in defaultStateForTasks) {
            if (parsed[key] === undefined) {
                parsed[key] = defaultStateForTasks[key];
            }
        }

        return parsed;

    } catch (error) {
        console.error("Critical error during loadFromLocalStorage:", error);
        localStorage.removeItem(STORAGE_KEY);
        const defaultOnErrorState = { // Объединенный из КОД1 и КОД2
            equipped: getDefaultEquippedSet(), collectedArtifacts: new Set(), gold: 0, diamonds: 0, toncoinShards: 0,
            toncoinBalance: 0, username: null, powerLevel: 0,
            playerBaseStats: { ...DEFAULT_BASE_STATS }, playerHp: DEFAULT_BASE_STATS.hp, playerRace: null, inventory: [],
            energyMax: DEFAULT_MAX_ENERGY, energyCurrent: DEFAULT_MAX_ENERGY, lastEnergyRefillTimestamp: Date.now(),
            dailyShopPurchases: {}, achievementsStatus: {}, totalGoldCollected: 0, totalKills: 0, booleanFlags: {},
            levelsCompleted: {}, achievementLevel: 1, achievementXp: 0, artifactLevels: {}, artifactChestPity: {},
            gearKeys: 0, totalArtifactChestsOpened: 0, gearChestPity: {}, totalGearChestsOpened: 0, dailyDeals: [],
            dailyDealsLastGenerated: null, lastOpenedChestInfo: null, lastChestRewards: null, treasureChestAttempts: 3,
            treasureChestLastReset: null, activeDebuffs: [], isAffectedByWeakeningAura: false, completedZones: {},
            userPhotoUrl: null, currentChapterId: INITIAL_CHAPTER_ID,
            levelChestStates: {}, // из КОД2
            ...defaultStateForTasks,
            ...getDefaultShardPassState() // Добавляем ShardPass дефолты при ошибке (из КОД1)
        };
        return defaultOnErrorState;
    }
};

const RARITY_WEIGHTS = { common: 100, uncommon: 50, rare: 25, legendary: 8, mythic: 2 }; // из КОД2 (legendary vs Mythic)
function weightedRandom(itemsWithWeight) { // из КОД2
    if (!itemsWithWeight || itemsWithWeight.length === 0) {
        console.error('[weightedRandom] Получен пустой или невалидный массив!');
        return null;
    }
    let totalWeight = itemsWithWeight.reduce((sum, entry) => {
        const weight = entry?.weight ?? 0;
        if (typeof weight !== 'number' || isNaN(weight) || weight < 0) {
            console.warn('[weightedRandom] Невалидный вес у элемента:', entry, 'Используем 0.');
            return sum;
        }
        return sum + weight;
    }, 0);

    if (totalWeight <= 0) {
        console.warn('[weightedRandom] Общий вес <= 0. Возврат случайного элемента (если есть).');
        return itemsWithWeight.length > 0 ? itemsWithWeight[Math.floor(Math.random() * itemsWithWeight.length)].item : null;
    }
    let random = Math.random() * totalWeight;
    for (let i = 0; i < itemsWithWeight.length; i++) {
        const currentWeight = itemsWithWeight[i]?.weight ?? 0;
        if (random < currentWeight) {
            return itemsWithWeight[i]?.item;
        }
        random -= currentWeight;
    }
    console.error('[weightedRandom] Цикл завершился без выбора! Этого не должно происходить при totalWeight > 0. Возврат последнего элемента.');
    return itemsWithWeight.length > 0 ? itemsWithWeight[itemsWithWeight.length - 1]?.item : null;
}
const DAILY_DEAL_RARITY_WEIGHTS = { common: 70, uncommon: 25, rare: 5 }; // из КОД2
const _selectWeightedArtifactIdFromSet_ByRarity = (setId) => { // из КОД2
    const targetSet = ARTIFACT_SETS.find(s => s.id === setId);
    if (!targetSet || !targetSet.artifacts || targetSet.artifacts.length === 0) {
        console.error(`[SelectWeightedArtifact] Сет ${setId} не найден или пуст!`);
        return null;
    }
    const weightedArtifactPool = targetSet.artifacts.map(artifact => ({
        id: artifact.id,
        weight: RARITY_WEIGHTS[artifact.rarity.toLowerCase()] || 1
    }));
    const totalWeight = weightedArtifactPool.reduce((sum, item) => sum + item.weight, 0);
    if (totalWeight <= 0) {
        console.warn(`[SelectWeightedArtifact] Все веса для сета ${setId} нулевые, выбор случайный.`);
        const randomIndex = Math.floor(Math.random() * weightedArtifactPool.length);
        return weightedArtifactPool[randomIndex].id;
    }
    let randomValue = Math.random() * totalWeight;
    for (const item of weightedArtifactPool) {
        if (randomValue < item.weight) {
            return item.id;
        }
        randomValue -= item.weight;
    }
    console.warn(`[SelectWeightedArtifact] Ошибка взвешенного выбора для сета ${setId}, возврат последнего элемента.`);
    return weightedArtifactPool[weightedArtifactPool.length - 1].id;
};
const _rollWeightedRarity_Gear = (rarityChances) => { // из КОД2
    if (!rarityChances || Object.keys(rarityChances).length === 0) {
        console.error("[RollRarityGear] Объект шансов пуст!");
        return 'Common';
    }
    const totalWeight = Object.values(rarityChances).reduce((sum, chance) => sum + (chance || 0), 0);
    if (totalWeight <= 0) {
        console.warn("[RollRarityGear] Сумма шансов равна нулю, возвращаем первую редкость.");
        return Object.keys(rarityChances)[0] || 'Common';
    }
    const randomValue = Math.random() * totalWeight;
    let cumulativeWeight = 0;
    for (const [rarity, chance] of Object.entries(rarityChances)) {
        cumulativeWeight += (chance || 0);
        if (randomValue < cumulativeWeight) {
            return rarity;
        }
    }
    console.warn("[RollRarityGear] Не удалось выбрать редкость по весу, возврат последнего.");
    return Object.keys(rarityChances).pop() || 'Common';
};
const _selectRandomGearItemByRarity_Gear = (targetRarity) => { // из КОД2
    const possibleItems = itemsDatabase.filter(item => item.rarity === targetRarity);
    if (possibleItems.length === 0) {
        console.error(`[SelectGearByRarity] Нет предметов снаряжения с редкостью ${targetRarity} в itemsDatabase! Попытка найти Common.`);
        const commonItems = itemsDatabase.filter(item => item.rarity === 'Common');
        if (commonItems.length > 0) {
            const randomIndex = Math.floor(Math.random() * commonItems.length);
            return { ...commonItems[randomIndex] };
        }
        console.error(`[SelectGearByRarity] Нет даже Common предметов! Возврат null.`);
        return null;
    }
    const randomIndex = Math.floor(Math.random() * possibleItems.length);
    return { ...possibleItems[randomIndex] };
};

const savedState = loadFromLocalStorage();

const useGameStore = create((set, get) => ({
    // ================== Состояние (State) - Объединенное из КОД1 и КОД2 ==================
    gold: savedState.gold,
    diamonds: savedState.diamonds,
    toncoinShards: savedState.toncoinShards || 0,
    toncoinBalance: savedState.toncoinBalance || 0,
    username: savedState.username,
    userPhotoUrl: savedState.userPhotoUrl,
    powerLevel: savedState.powerLevel,
    energyMax: savedState.energyMax,
    energyCurrent: savedState.energyCurrent,
    lastEnergyRefillTimestamp: savedState.lastEnergyRefillTimestamp,
    lastOpenedLevelChestRewards: savedState.lastOpenedLevelChestRewards, // из КОД2, было null
    levelChestStates: savedState.levelChestStates || {}, // из КОД1, также в КОД2
    currentLevelRewards: savedState.currentLevelRewards || { gold: 0, diamonds: 0, items: [] }, // из КОД2
    currentChapterId: savedState.currentChapterId,
    completedZones: savedState.completedZones,
    hasClaimableRewardsIndicator: savedState.hasClaimableRewardsIndicator || false, // из КОД2
    playerHp: savedState.playerHp,
    playerRace: savedState.playerRace,
    playerBaseStats: savedState.playerBaseStats,
    inventory: savedState.inventory,
    equipped: savedState.equipped,
    collectedArtifacts: savedState.collectedArtifacts, // Should be a Set
    artifactLevels: savedState.artifactLevels,
    dailyShopPurchases: savedState.dailyShopPurchases,
    achievementsStatus: savedState.achievementsStatus,
    totalGoldCollected: savedState.totalGoldCollected,
    totalKills: savedState.totalKills,
    booleanFlags: savedState.booleanFlags,
    levelsCompleted: savedState.levelsCompleted,
    achievementLevel: savedState.achievementLevel,
    achievementXp: savedState.achievementXp,
    artifactChestPity: savedState.artifactChestPity,
    gearKeys: savedState.gearKeys,
    totalArtifactChestsOpened: savedState.totalArtifactChestsOpened,
    gearChestPity: savedState.gearChestPity,
    totalGearChestsOpened: savedState.totalGearChestsOpened,
    lastOpenedChestInfo: savedState.lastOpenedChestInfo,
    lastChestRewards: savedState.lastChestRewards,
    dailyDeals: savedState.dailyDeals,
    dailyDealsLastGenerated: savedState.dailyDealsLastGenerated,
    isFullScreenMapActive: savedState.isFullScreenMapActive || false, // из КОД2
    activeDebuffs: savedState.activeDebuffs,
    isScreenTransitioning: savedState.isScreenTransitioning || false, // из КОД2
    transitionAction: savedState.transitionAction || null, // из КОД2
    onTransitionCloseCompleteCallback: null, // из КОД2
    onTransitionOpenCompleteCallback: null, // из КОД2
    treasureChestAttempts: savedState.treasureChestAttempts,
    treasureChestLastReset: savedState.treasureChestLastReset,
    isAffectedByWeakeningAura: savedState.isAffectedByWeakeningAura,

    // Состояния для задач (из КОД1, также в КОД2)
    dailyTaskProgress: savedState.dailyTaskProgress,
    dailyTaskBarXp: savedState.dailyTaskBarXp,
    dailyBonusClaimed: savedState.dailyBonusClaimed,
    lastDailyReset: savedState.lastDailyReset,
    dailyLoginToday: savedState.dailyLoginToday,
    killsToday: savedState.killsToday,
    levelsCompletedToday: savedState.levelsCompletedToday,
    gearUpgradedToday: savedState.gearUpgradedToday,
    chestsOpenedToday: savedState.chestsOpenedToday,
    lastSeenLoginDateForWeekly: savedState.lastSeenLoginDateForWeekly,
    lastSeenLoginDateForMonthly: savedState.lastSeenLoginDateForMonthly,
    weeklyTaskProgress: savedState.weeklyTaskProgress,
    weeklyTaskBarXp: savedState.weeklyTaskBarXp,
    weeklyBonusClaimed: savedState.weeklyBonusClaimed,
    lastWeeklyReset: savedState.lastWeeklyReset,
    weeklyLoginDays: savedState.weeklyLoginDays,
    killsThisWeek: savedState.killsThisWeek,
    levelsCompletedThisWeek: savedState.levelsCompletedThisWeek,
    gearUpgradedThisWeek: savedState.gearUpgradedThisWeek,
    chestsOpenedThisWeek: savedState.chestsOpenedThisWeek,
    monthlyTaskProgress: savedState.monthlyTaskProgress,
    monthlyTaskBarXp: savedState.monthlyTaskBarXp,
    monthlyBonusClaimed: savedState.monthlyBonusClaimed,
    lastMonthlyReset: savedState.lastMonthlyReset,
    monthlyLoginDays: savedState.monthlyLoginDays,
    killsThisMonth: savedState.killsThisMonth,
    levelsCompletedThisMonth: savedState.levelsCompletedThisMonth,
    gearUpgradedThisMonth: savedState.gearUpgradedThisMonth,
    chestsOpenedThisMonth: savedState.chestsOpenedThisMonth,

    // <<< НОВОЕ СОСТОЯНИЕ ДЛЯ SHARDPASS (из КОД1) >>>
    shardPassSeasonId: savedState.shardPassSeasonId,
    shardPassCurrentLevel: savedState.shardPassCurrentLevel,
    shardPassCurrentXp: savedState.shardPassCurrentXp,
    shardPassXpPerLevel: savedState.shardPassXpPerLevel,
    shardPassMaxLevel: savedState.shardPassMaxLevel,
    isShardPassPremium: savedState.isShardPassPremium,
    shardPassRewardsClaimed: savedState.shardPassRewardsClaimed,
    shardPassTasksProgress: savedState.shardPassTasksProgress,
    shardPassSeasonStartDateUTC: savedState.shardPassSeasonStartDateUTC,

    // ================== Селекторы (Computed/Getters) ==================
    computedStats: () => { // из КОД2, т.к. более полная реализация с дебаффами
        const state = get();
        const now = Date.now();
        const currentActiveDebuffs = (state.activeDebuffs || []).filter(debuff => now < debuff.endTime);
        let totalWeakenDamageReductionPercent = 0;
        let totalWeakenMaxHpReductionPercent = 0;
        let totalOtherDamageReductionPercent = 0;
        let totalOtherMaxHpReductionPercent = 0;

        currentActiveDebuffs.forEach(debuff => {
            if (debuff.type === 'weaken') {
                totalWeakenDamageReductionPercent += (debuff.strength || 0);
                totalWeakenMaxHpReductionPercent += (debuff.strength || 0);
            } else {
                if (debuff.hasOwnProperty('damageReductionPercent')) {
                    totalOtherDamageReductionPercent += (debuff.damageReductionPercent || 0);
                }
                if (debuff.hasOwnProperty('maxHpReductionPercent')) {
                    totalOtherMaxHpReductionPercent += (debuff.maxHpReductionPercent || 0);
                }
            }
        });

        totalWeakenDamageReductionPercent = Math.min(totalWeakenDamageReductionPercent, 80);
        totalWeakenMaxHpReductionPercent = Math.min(totalWeakenMaxHpReductionPercent, 80);
        totalOtherDamageReductionPercent = Math.min(totalOtherDamageReductionPercent, 80);
        totalOtherMaxHpReductionPercent = Math.min(totalOtherMaxHpReductionPercent, 80);

        let finalStats = { ...DEFAULT_BASE_STATS, ...(state.playerBaseStats || {}) };
        let totalGearAttackSpeedPercentBonus = 0;

        for (const slot in state.equipped) {
            const item = state.equipped[slot];
            if (item) {
                finalStats.hp = (finalStats.hp || 0) + (item.hpBonus || 0);
                finalStats.attack = (finalStats.attack || 0) + (item.attackBonus || 0);
                totalGearAttackSpeedPercentBonus += item.attackSpeedBonus || 0;
                finalStats.critChance = (finalStats.critChance || 0) + (item.critChanceBonus || 0);
                finalStats.doubleStrikeChance = (finalStats.doubleStrikeChance || 0) + (item.doubleStrikeChanceBonus || 0);
                finalStats.speed = (finalStats.speed || 0) + (item.speedBonus || 0);
                finalStats.range = (finalStats.range || 0) + (item.rangeBonus || 0);
                finalStats.defense = (finalStats.defense || 0) + (item.defenseBonus || 0);
                finalStats.luck = (finalStats.luck || 0) + (item.luckBonus || 0);
                finalStats.hpRegen = (finalStats.hpRegen || 0) + (item.hpRegenBonus || 0);
                finalStats.evasion = (finalStats.evasion || 0) + (item.evasionBonus || 0);
                finalStats.maxMana = (finalStats.maxMana || 0) + (item.maxManaBonus || 0);
                finalStats.elementalDmgPercent = (finalStats.elementalDmgPercent || 0) + (item.elementalDmgPercentBonus || 0);
                finalStats.goldFind = (finalStats.goldFind || 0) + (item.goldFindBonus || 0);
                finalStats.bossDmg = (finalStats.bossDmg || 0) + (item.bossDmgBonus || 0);
                finalStats.shardFind = (finalStats.shardFind || 0) + (item.shardFindBonus || 0);
                finalStats.atkPercentBonus = (finalStats.atkPercentBonus || 0) + (item.atkPercentBonus || 0);
                finalStats.moveSpeedPercentBonus = (finalStats.moveSpeedPercentBonus || 0) + (item.moveSpeedPercentBonus || 0);
                finalStats.bonusProjectiles = (finalStats.bonusProjectiles || 0) + (item.bonusProjectiles || 0);
            }
        }

        const { artifactLevels, collectedArtifacts } = state;
        let totalArtifactHp = 0, totalArtifactAttack = 0, totalArtifactDefense = 0, totalArtifactHpRegen = 0,
            totalArtifactAttackSpeed = 0, totalArtifactEvasion = 0, totalArtifactMoveSpeedBonus = 0,
            totalArtifactAtkPercentBonus = 0, totalArtifactMaxMana = 0, totalArtifactElementalDmgPercent = 0,
            totalArtifactCritChance = 0, totalArtifactDoubleStrikeChance = 0, totalArtifactGoldFind = 0,
            totalArtifactLuck = 0, totalArtifactBossDmg = 0, totalArtifactShardFind = 0, totalArtifactBonusProjectiles = 0;

        for (const artifactId in artifactLevels) {
            if (collectedArtifacts.has(artifactId)) {
                const artifactData = getArtifactById(artifactId);
                const artifactInfo = artifactLevels[artifactId];
                if (artifactData && artifactInfo) {
                    const level = artifactInfo.level;
                    if (level <= 0) continue;

                    if (artifactData.baseStats) {
                        for (const [statName, baseValue] of Object.entries(artifactData.baseStats)) {
                            switch (statName) {
                                case "hp": totalArtifactHp += baseValue; break;
                                case "attack": totalArtifactAttack += baseValue; break;
                                case "defense": totalArtifactDefense += baseValue; break;
                                case "hpRegen": totalArtifactHpRegen += baseValue; break;
                                case "attackSpeed": totalArtifactAttackSpeed += baseValue; break;
                                case "evasion": totalArtifactEvasion += baseValue; break;
                                case "moveSpeedPercentBonus": totalArtifactMoveSpeedBonus += baseValue; break;
                                case "atkPercentBonus": totalArtifactAtkPercentBonus += baseValue; break;
                                case "maxMana": totalArtifactMaxMana += baseValue; break;
                                case "elementalDmgPercent": totalArtifactElementalDmgPercent += baseValue; break;
                                case "critChance": totalArtifactCritChance += baseValue; break;
                                case "doubleStrikeChance": totalArtifactDoubleStrikeChance += baseValue; break;
                                case "goldFind": totalArtifactGoldFind += baseValue; break;
                                case "luck": totalArtifactLuck += baseValue; break;
                                case "bossDmg": totalArtifactBossDmg += baseValue; break;
                                case "shardFind": totalArtifactShardFind += baseValue; break;
                                case "bonusProjectiles": totalArtifactBonusProjectiles += baseValue; break;
                                default: console.warn(`[WARN] Неизвестный БАЗОВЫЙ стат артефакта '${artifactId}': ${statName}`); break;
                            }
                        }
                    }
                    if (artifactData.levelStats) {
                        for (const [statName, levelValue] of Object.entries(artifactData.levelStats)) {
                            const bonus = levelValue * level;
                            if (bonus === 0 && levelValue !==0) continue;
                             switch (statName) {
                                case "hp": totalArtifactHp += bonus; break;
                                case "attack": totalArtifactAttack += bonus; break;
                                case "defense": totalArtifactDefense += bonus; break;
                                case "hpRegen": totalArtifactHpRegen += bonus; break;
                                case "attackSpeed": totalArtifactAttackSpeed += bonus; break;
                                case "evasion": totalArtifactEvasion += bonus; break;
                                case "moveSpeedPercentBonus": totalArtifactMoveSpeedBonus += bonus; break;
                                case "atkPercentBonus": totalArtifactAtkPercentBonus += bonus; break;
                                case "maxMana": totalArtifactMaxMana += bonus; break;
                                case "elementalDmgPercent": totalArtifactElementalDmgPercent += bonus; break;
                                case "critChance": totalArtifactCritChance += bonus; break;
                                case "doubleStrikeChance": totalArtifactDoubleStrikeChance += bonus; break;
                                case "goldFind": totalArtifactGoldFind += bonus; break;
                                case "luck": totalArtifactLuck += bonus; break;
                                case "bossDmg": totalArtifactBossDmg += bonus; break;
                                case "shardFind": totalArtifactShardFind += bonus; break;
                                case "bonusProjectiles": totalArtifactBonusProjectiles += bonus; break;
                                default: console.warn(`[WARN] Неизвестный стат УРОВНЯ артефакта '${artifactId}': ${statName}`); break;
                            }
                        }
                    }
                } else {
                    console.warn(`[WARN] Не найдены данные или информация об уровне для артефакта ID: ${artifactId}`);
                }
            }
        }
        finalStats.hp += totalArtifactHp;
        finalStats.attack += totalArtifactAttack;
        finalStats.defense += totalArtifactDefense;
        finalStats.hpRegen += totalArtifactHpRegen;
        totalGearAttackSpeedPercentBonus += totalArtifactAttackSpeed;
        finalStats.critChance += totalArtifactCritChance;
        finalStats.doubleStrikeChance += totalArtifactDoubleStrikeChance;
        finalStats.evasion += totalArtifactEvasion;
        finalStats.moveSpeedPercentBonus = (finalStats.moveSpeedPercentBonus || 0) + totalArtifactMoveSpeedBonus;
        finalStats.atkPercentBonus = (finalStats.atkPercentBonus || 0) + totalArtifactAtkPercentBonus;
        finalStats.maxMana += totalArtifactMaxMana;
        finalStats.elementalDmgPercent += totalArtifactElementalDmgPercent;
        finalStats.goldFind += totalArtifactGoldFind;
        finalStats.luck += totalArtifactLuck;
        finalStats.bossDmg += totalArtifactBossDmg;
        finalStats.shardFind += totalArtifactShardFind;
        finalStats.bonusProjectiles += totalArtifactBonusProjectiles;

        ARTIFACT_SETS.forEach(set => {
            const activeOwnedInSet = set.artifacts.filter(artifact => {
                const stateInfo = artifactLevels[artifact.id];
                return collectedArtifacts.has(artifact.id) && stateInfo && stateInfo.level > 0;
            }).length;

            set.bonuses.forEach(bonus => {
                const match = bonus.condition.match(/\[\s*Собрано\s*(\d+)\s*\]/i);
                const requiredCount = match ? parseInt(match[1], 10) : 0;
                if (requiredCount > 0 && activeOwnedInSet >= requiredCount) {
                    const desc = bonus.description.toLowerCase();
                    const valueMatch = desc.match(/([+-]?\d+(\.\d+)?)/);
                    const value = valueMatch ? parseFloat(valueMatch[1]) : 0;
                    let applied = false;
                    if (desc.includes('макс. hp') || (desc.includes('hp') && !desc.includes('регенерация'))) {
                        if (desc.includes('%')) finalStats.hp *= (1 + value / 100); else finalStats.hp += value;
                        applied = true;
                    } else if (desc.includes('сила атаки') || desc.includes('урон') || desc.includes('атак')) {
                        if (desc.includes('%')) finalStats.atkPercentBonus = (finalStats.atkPercentBonus || 0) + value; else finalStats.attack += value;
                        applied = true;
                    } else if (desc.includes('скорость атаки')) {
                        if (desc.includes('%')) totalGearAttackSpeedPercentBonus += value; applied = true;
                    } else if (desc.includes('регенерация hp')) {
                        finalStats.hpRegen = (finalStats.hpRegen || 0) + value; applied = true;
                    } else if (desc.includes('шанс двойного удара') || desc.includes('двойной удар')) {
                        finalStats.doubleStrikeChance = (finalStats.doubleStrikeChance || 0) + value; applied = true;
                    } else if (desc.includes('шанс найти золото') || desc.includes('поиск золота')) {
                        finalStats.goldFind = (finalStats.goldFind || 0) + value; applied = true;
                    } else if (desc.includes('шанс найти осколки') || desc.includes('поиск осколков')) {
                        finalStats.shardFind = (finalStats.shardFind || 0) + value; applied = true;
                    } else if (desc.includes('шанс крит. удара') || desc.includes('крит. шанс')) {
                        finalStats.critChance = (finalStats.critChance || 0) + value; applied = true;
                    } else if (desc.includes('защита')) {
                        finalStats.defense = (finalStats.defense || 0) + value; applied = true;
                    } else if (desc.includes('удача')) {
                        finalStats.luck = (finalStats.luck || 0) + value; applied = true;
                    } else if (desc.includes('урон боссам')) {
                        finalStats.bossDmg = (finalStats.bossDmg || 0) + value; applied = true;
                    } else if (desc.includes('урон стихиями')) {
                        finalStats.elementalDmgPercent = (finalStats.elementalDmgPercent || 0) + value; applied = true;
                    } else if (desc.includes('макс. мана') || desc.includes('мана')) {
                        finalStats.maxMana = (finalStats.maxMana || 0) + value; applied = true;
                    } else if (desc.includes('шанс уклонения') || desc.includes('уклонение')) {
                        finalStats.evasion = (finalStats.evasion || 0) + value; applied = true;
                    } else if (desc.includes('скорость передвижения')) {
                        finalStats.moveSpeedPercentBonus = (finalStats.moveSpeedPercentBonus || 0) + value; applied = true;
                    } else if (desc.includes('+1 доп. снаряд при атаке') || desc.includes('доп. снаряд')) {
                         finalStats.bonusProjectiles = (finalStats.bonusProjectiles || 0) + 1; applied = true;
                    }
                    if (!applied) console.warn(`[WARN] Не удалось распознать бонус сета '${set.name}': ${bonus.description}`);
                }
            });
        });

        finalStats.attack = (finalStats.attack || 0) * (1 + (finalStats.atkPercentBonus || 0) / 100);
        finalStats.attackSpeed = (finalStats.attackSpeed || DEFAULT_BASE_STATS.attackSpeed || 1.0) * (1 + totalGearAttackSpeedPercentBonus / 100);
        finalStats.speed = (finalStats.speed || DEFAULT_BASE_STATS.speed || 5) * (1 + (finalStats.moveSpeedPercentBonus || 0) / 100);

        let debuffLogMessages = [];
        let attackBeforeModification, hpBeforeModification;

        if (totalOtherDamageReductionPercent > 0 || totalOtherMaxHpReductionPercent > 0) {
            attackBeforeModification = finalStats.attack;
            hpBeforeModification = finalStats.hp;
            if (totalOtherDamageReductionPercent > 0) {
                finalStats.attack *= (1 - totalOtherDamageReductionPercent / 100);
                debuffLogMessages.push(`Attack reduced by ${totalOtherDamageReductionPercent}% (other debuff). (${attackBeforeModification.toFixed(1)} -> ${finalStats.attack.toFixed(1)})`);
            }
            if (totalOtherMaxHpReductionPercent > 0) {
                finalStats.hp *= (1 - totalOtherMaxHpReductionPercent / 100);
                debuffLogMessages.push(`HP reduced by ${totalOtherMaxHpReductionPercent}% (other debuff). (${hpBeforeModification.toFixed(1)} -> ${finalStats.hp.toFixed(1)})`);
            }
        }

        if (totalWeakenDamageReductionPercent > 0 || totalWeakenMaxHpReductionPercent > 0) {
            attackBeforeModification = finalStats.attack;
            hpBeforeModification = finalStats.hp;
            if (totalWeakenDamageReductionPercent > 0) {
                finalStats.attack *= (1 - totalWeakenDamageReductionPercent / 100);
                debuffLogMessages.push(`Attack reduced by ${totalWeakenDamageReductionPercent}% (weaken debuff). (${attackBeforeModification.toFixed(1)} -> ${finalStats.attack.toFixed(1)})`);
            }
            if (totalWeakenMaxHpReductionPercent > 0) {
                finalStats.hp *= (1 - totalWeakenMaxHpReductionPercent / 100);
                debuffLogMessages.push(`HP reduced by ${totalWeakenMaxHpReductionPercent}% (weaken debuff). (${hpBeforeModification.toFixed(1)} -> ${finalStats.hp.toFixed(1)})`);
            }
        }
        
        const auraIsActive = state.isAffectedByWeakeningAura;
        const auraStrengthPercent = 10;
        if (auraIsActive) {
            attackBeforeModification = finalStats.attack;
            hpBeforeModification = finalStats.hp;
            finalStats.attack *= (1 - auraStrengthPercent / 100);
            debuffLogMessages.push(`Attack reduced by ${auraStrengthPercent}% (aura). (${attackBeforeModification.toFixed(1)} -> ${finalStats.attack.toFixed(1)})`);
            finalStats.hp *= (1 - auraStrengthPercent / 100);
            debuffLogMessages.push(`HP reduced by ${auraStrengthPercent}% (aura). (${hpBeforeModification.toFixed(1)} -> ${finalStats.hp.toFixed(1)})`);
        }

        if (debuffLogMessages.length > 0) {
            // console.log("Debuffs/Aura Applied:", debuffLogMessages.join('; '));
        }

        finalStats.hp = Math.max(1, Math.round(finalStats.hp || 0));
        finalStats.attack = Math.max(0, Math.round(finalStats.attack || 0));
        finalStats.attackSpeed = parseFloat(Math.max(0.1, (finalStats.attackSpeed || 0)).toFixed(2));
        finalStats.critChance = Math.min(100, Math.max(0, Math.round(finalStats.critChance || 0)));
        finalStats.doubleStrikeChance = Math.min(100, Math.max(0, Math.round(finalStats.doubleStrikeChance || 0)));
        finalStats.speed = parseFloat(Math.max(0.1, (finalStats.speed || 0)).toFixed(2));
        finalStats.range = Math.max(1, Math.round(finalStats.range || 0));
        finalStats.skin = finalStats.skin || DEFAULT_BASE_STATS.skin;
        finalStats.defense = Math.max(0, Math.round(finalStats.defense || 0));
        finalStats.hpRegen = Math.max(0, parseFloat((finalStats.hpRegen || 0).toFixed(1)));
        finalStats.evasion = Math.min(90, Math.max(0, Math.round(finalStats.evasion || 0)));
        finalStats.maxMana = Math.max(0, Math.round(finalStats.maxMana || 0));
        finalStats.elementalDmgPercent = Math.max(0, Math.round(finalStats.elementalDmgPercent || 0));
        finalStats.goldFind = Math.max(0, Math.round(finalStats.goldFind || 0));
        finalStats.luck = Math.max(0, Math.round(finalStats.luck || 0));
        finalStats.bossDmg = Math.max(0, Math.round(finalStats.bossDmg || 0));
        finalStats.shardFind = Math.max(0, Math.round(finalStats.shardFind || 0));
        finalStats.bonusProjectiles = Math.max(0, Math.round(finalStats.bonusProjectiles || 0));

        for (const key in finalStats) {
            if (typeof finalStats[key] === 'number' && isNaN(finalStats[key])) {
                console.warn(`Computed stat ${key} was NaN. Resetting to default.`);
                finalStats[key] = DEFAULT_BASE_STATS[key] ?? 0;
            }
        }
        return finalStats;
    },
    isAnyRecipeCraftable: () => { // из КОД2
        const { inventory, gold, diamonds } = get();
        const inventoryCounts = {};
        inventory.forEach(item => {
            if (item?.id && item?.rarity) {
                const key = `${item.id}_${item.rarity}`;
                inventoryCounts[key] = (inventoryCounts[key] || 0) + 1;
            } else if (item?.id) {
                inventoryCounts[item.id] = (inventoryCounts[item.id] || 0) + 1;
            }
        });

        for (const recipe of forgeRecipes) {
            let hasEnoughItems = true;
            for (const input of recipe.inputItems) {
                const key = input.rarity ? `${input.itemId}_${input.rarity}` : input.itemId;
                if ((inventoryCounts[key] || 0) < input.quantity) {
                    hasEnoughItems = false;
                    break;
                }
            }
            if (!hasEnoughItems) continue;

            if (gold >= recipe.cost.gold && diamonds >= recipe.cost.diamonds) {
                return true;
            }
        }
        return false;
    },
    getAchievementXpNeededForNextLevel: () => getXpNeededForLevel(get().achievementLevel), // из КОД1, также в КОД2
    getCurrentLevelXpProgress: () => Math.max(0, get().achievementXp - (ACHIEVEMENT_LEVEL_XP_THRESHOLDS[get().achievementLevel] ?? 0)), // из КОД1, также в КОД2
    getXpNeededForCurrentLevelUp: () => { // из КОД1, также в КОД2
        const lvl = get().achievementLevel;
        const nextThreshold = getXpNeededForLevel(lvl);
        const currentThreshold = ACHIEVEMENT_LEVEL_XP_THRESHOLDS[lvl] ?? 0;
        return nextThreshold === Infinity ? Infinity : nextThreshold - currentThreshold;
    },

    // ================== Действия (Actions) - Объединенные и Дополненные ==================
    setUsername: (name) => set({ username: name }),
    setGold: (amount) => set({ gold: amount }),
    setDiamonds: (amount) => set({ diamonds: amount }),
    setTelegramPhotoUrl: (photoUrl) => set({ userPhotoUrl: photoUrl || null }),
    setPlayerRace: (raceId) => get().initializeCharacterStats(raceId),
    initializeCharacterStats: (raceId) => {
        const raceData = getRaceDataById(raceId);
        const initialStats = raceData ? raceData.initialStats : DEFAULT_BASE_STATS;
        set({
            playerBaseStats: { ...initialStats },
            playerHp: initialStats.hp,
            playerRace: raceId,
        });
        get().updatePowerLevel();
        get().initializeLevelHp();
    },
    playerTakeDamage: (damageAmount) => {
        set((state) => {
            const newHp = Math.max(0, state.playerHp - damageAmount);
            return { playerHp: newHp };
        });
        if (get().playerHp <= 0) {
            console.log("Игрок погиб!");
            // TODO: Handle player death
        }
    },
    initializeLevelHp: () => {
        const maxHp = get().computedStats().hp;
        set({ playerHp: maxHp });
    },
    healPlayer: (amount) => {
        set((state) => {
            const maxHp = get().computedStats().hp;
            const newHp = Math.min(maxHp, state.playerHp + amount);
            return { playerHp: newHp };
        });
    },
    addGold: (amount) => { // Из КОД1 (с trackTaskEvent)
        if (amount === 0) return;
        set((state) => ({
            gold: state.gold + amount,
            totalGoldCollected: amount > 0 ? state.totalGoldCollected + amount : state.totalGoldCollected,
        }));
        get().checkAllAchievements();
        get().trackTaskEvent('earn_gold', amount);
    },
    addDiamonds: (amount) => { // Из КОД1 (с trackTaskEvent)
        if (amount === 0) return;
        set((state) => ({ diamonds: state.diamonds + amount }));
        get().checkAllAchievements();
        get().trackTaskEvent('earn_diamonds', amount);
    },
    addToncoinShards: (amount) => { // Из КОД1 (с trackTaskEvent)
        if (amount <= 0) return;
        set((state) => ({ toncoinShards: (state.toncoinShards || 0) + amount }));
        get().trackTaskEvent('earn_toncoin_shards', amount);
    },
    spendToncoinShards: (amount) => { // из КОД2
        if (amount <= 0) return false;
        const currentShards = get().toncoinShards || 0;
        if (currentShards < amount) {
            console.warn(`[Currency] Not enough TON Shards to spend. Has: ${currentShards}, Tried to spend: ${amount}`);
            return false;
        }
        set((state) => {
            const newAmount = state.toncoinShards - amount;
            console.log(`[Currency] Spent ${amount} TON Shards. Remaining: ${newAmount}`);
            return { toncoinShards: newAmount };
        });
        return true;
    },
    exchangeShardsToTon: (shardsToSpend) => { // из КОД2
        const currentShards = get().toncoinShards;
        if (typeof shardsToSpend !== 'number' || shardsToSpend <= 0) {
            console.warn("[Exchange] Invalid amount of shards to spend:", shardsToSpend);
            return { success: false, message: "Неверное количество осколков." };
        }
        if (currentShards < shardsToSpend) {
            console.warn(`[Exchange] Not enough TON Shards. Has: ${currentShards}, Tried to spend: ${shardsToSpend}`);
            return { success: false, message: "Недостаточно осколков для обмена." };
        }
        if (TON_SHARD_TO_TON_EXCHANGE_RATE <= 0) {
            console.error("[Exchange] Invalid exchange rate configured.");
            return { success: false, message: "Ошибка конфигурации курса обмена." };
        }
        const tonToReceive = shardsToSpend / TON_SHARD_TO_TON_EXCHANGE_RATE;
        set((state) => ({
            toncoinShards: state.toncoinShards - shardsToSpend,
            toncoinBalance: (state.toncoinBalance || 0) + tonToReceive,
        }));
        console.log(`[Exchange] Exchanged ${shardsToSpend} shards for ${tonToReceive} TON. New shard balance: ${get().toncoinShards}, New TON balance: ${get().toncoinBalance}`);
        return { success: true, message: `Обмен успешно совершен! Вы получили ${tonToReceive.toFixed(4)} TON.` };
    },
    requestToncoinWithdrawal: async (amountToWithdraw, address) => { // из КОД2
        const currentTonBalance = get().toncoinBalance;
        if (typeof amountToWithdraw !== 'number' || amountToWithdraw <= 0) {
            console.warn("[Withdrawal] Invalid amount to withdraw:", amountToWithdraw);
            return { success: false, message: "Неверная сумма для вывода." };
        }
        if (!address || typeof address !== 'string' || address.trim().length < 10) {
            console.warn("[Withdrawal] Invalid address:", address);
            return { success: false, message: "Неверный адрес для вывода." };
        }
        if (currentTonBalance < amountToWithdraw) {
            console.warn(`[Withdrawal] Not enough TON. Has: ${currentTonBalance}, Tried to withdraw: ${amountToWithdraw}`);
            return { success: false, message: "Недостаточно TON для вывода." };
        }
        await new Promise(resolve => setTimeout(resolve, 1500)); // Imitation
        set((state) => ({
            toncoinBalance: state.toncoinBalance - amountToWithdraw,
        }));
        console.log(`[Withdrawal SIMULATION] Requested withdrawal of ${amountToWithdraw} TON to address ${address}. New TON balance: ${get().toncoinBalance}`);
        return { success: true, message: `Запрос на вывод ${amountToWithdraw.toFixed(4)} TON на адрес ${address.substring(0,6)}...${address.substring(address.length-4)} успешно отправлен (имитация).` };
    },
    incrementKills: (count = 1) => { // из КОД2, trackTaskEvent уже есть в addGold/Diamonds/Shards
        set((state) => ({ totalKills: state.totalKills + count }));
        get().trackTaskEvent('kill_monster', count); // Universal task event tracker from code1
        get().checkAllAchievements();
    },
    refillEnergyOnLoad: () => { // из КОД2
        set((state) => {
            const now = Date.now();
            const { energyCurrent, energyMax, lastEnergyRefillTimestamp } = state;
            if (energyCurrent >= energyMax) {
                return { lastEnergyRefillTimestamp: now };
            }
            const elapsedMs = now - (lastEnergyRefillTimestamp || now);
            if (elapsedMs <= 0) return {};
            const refillIntervalsPassed = Math.floor(elapsedMs / ENERGY_REFILL_INTERVAL_MS);
            if (refillIntervalsPassed <= 0) return {};
            const energyToAdd = refillIntervalsPassed;
            const newEnergy = Math.min(energyMax, energyCurrent + energyToAdd);
            const timeConsumedByRefillMs = (newEnergy - energyCurrent) * ENERGY_REFILL_INTERVAL_MS;
            const newTimestamp = (lastEnergyRefillTimestamp || (now - elapsedMs)) + timeConsumedByRefillMs;
            if (newEnergy === energyCurrent) return {};
            return {
                energyCurrent: newEnergy,
                lastEnergyRefillTimestamp: newTimestamp,
            };
        });
    },
    consumeEnergy: (cost) => { // из КОД2
        if (cost <= 0) return false;
        let success = false;
        set((state) => {
            const { energyCurrent, energyMax, lastEnergyRefillTimestamp } = state;
            if (energyCurrent < cost) {
                console.warn(`Consume Energy: Недостаточно энергии. Нужно: ${cost}, есть: ${energyCurrent}`);
                success = false;
                return {};
            }
            const wasFull = energyCurrent >= energyMax;
            const newEnergy = energyCurrent - cost;
            const newTimestamp = wasFull ? Date.now() : lastEnergyRefillTimestamp;
            success = true;
            return {
                energyCurrent: newEnergy,
                lastEnergyRefillTimestamp: newTimestamp,
            };
        });
        return success;
    },
    addEnergy: (amount) => { // из КОД2
        if (amount <= 0) return;
        set((state) => {
            const newEnergy = Math.min(state.energyMax, state.energyCurrent + amount);
            return { energyCurrent: newEnergy };
        });
    },
    setEquipped: (payload) => set({ equipped: payload }),
    addItemToInventory: (itemId, quantity = 1) => { // Из КОД1 (с trackTaskEvent и eventDetails)
        const baseItem = getItemById(itemId);
        if (baseItem) {
            const newItems = Array.from({ length: quantity }).map(() => createItemInstance(baseItem));
            set((state) => ({ inventory: [...state.inventory, ...newItems] }));
            get().checkAllAchievements();
            get().trackTaskEvent('collect_item', quantity, { itemId, rarity: baseItem.rarity, type: baseItem.type });
        } else {
            console.warn(`Предмет ${itemId} не найден в базе данных!`);
        }
    },
    removeItemFromInventory: (uid) => {
        set((state) => ({
            inventory: state.inventory.filter(item => item.uid !== uid)
        }));
    },
    equipItem: (itemToEquip) => {
        if (!itemToEquip?.type || !itemToEquip.uid) return;
        const slot = itemToEquip.type;
        set((state) => {
            const currentEquippedItem = state.equipped[slot];
            let updatedInventory = state.inventory.filter((i) => i.uid !== itemToEquip.uid);
            if (currentEquippedItem) {
                updatedInventory.push(currentEquippedItem);
            }
            let flagUpdate = {};
            if (itemToEquip.rarity && itemToEquip.rarity.toLowerCase() === 'epic' && !state.booleanFlags.equippedEpic) {
                flagUpdate = { booleanFlags: { ...state.booleanFlags, equippedEpic: true } };
            }
            return {
                equipped: { ...state.equipped, [slot]: itemToEquip },
                inventory: updatedInventory,
                ...flagUpdate
            };
        });
        get().updatePowerLevel();
        get().initializeLevelHp();
    },
    unequipItem: (slot) => {
        set((state) => {
            const itemToUnequip = state.equipped[slot];
            if (!itemToUnequip) return {};
            return {
                equipped: { ...state.equipped, [slot]: null },
                inventory: [...state.inventory, itemToUnequip],
            };
        });
        get().updatePowerLevel();
        get().initializeLevelHp();
    },
    executeForgeRecipe: (recipe) => { // из КОД2, добавлен trackTaskEvent из КОД1
        if (!recipe?.inputItems || !recipe.outputItemId || !recipe.cost) {
            console.error("Forge Error: Invalid recipe data received.", recipe);
            return false;
        }
        const state = get();
        if (state.gold < recipe.cost.gold || state.diamonds < recipe.cost.diamonds) {
            console.warn("Forge Warning: Insufficient currency.");
            return false;
        }
        const itemsToRemoveUids = new Set();
        let tempInventory = [...state.inventory];
        for (const input of recipe.inputItems) {
            let foundCount = 0;
            for (let i = 0; i < input.quantity; i++) {
                const itemIndex = tempInventory.findIndex(invItem =>
                    invItem.id === input.itemId &&
                    (input.rarity ? invItem.rarity === input.rarity : true) &&
                    !itemsToRemoveUids.has(invItem.uid)
                );
                if (itemIndex !== -1) {
                    itemsToRemoveUids.add(tempInventory[itemIndex].uid);
                    foundCount++;
                } else {
                    console.error(`Forge Error: Insufficient items for input: ${input.itemId} (rarity: ${input.rarity || 'any'}), needed ${input.quantity}, found ${foundCount}`);
                    return false;
                }
            }
        }
        const outputItemBaseData = getItemById(recipe.outputItemId);
        if (!outputItemBaseData) {
            console.error(`Forge Error: Output item base data not found for ID: ${recipe.outputItemId}`);
            return false;
        }
        const forgedItem = createItemInstance(outputItemBaseData);
         if (!forgedItem) {
            console.error(`Forge Error: Could not create instance for output item ID: ${recipe.outputItemId}`);
            return false;
        }
        const currentForgeFlag = state.booleanFlags.hasForgedOrUpgraded;
        let flagUpdate = !currentForgeFlag ? { booleanFlags: { ...state.booleanFlags, hasForgedOrUpgraded: true } } : {};
        set((prevState) => {
            const newInventory = prevState.inventory.filter(item => !itemsToRemoveUids.has(item.uid));
            newInventory.push(forgedItem);
            return {
                inventory: newInventory,
                gold: prevState.gold - recipe.cost.gold,
                diamonds: prevState.diamonds - recipe.cost.diamonds,
                ...flagUpdate
            };
        });
        get().trackTaskEvent('upgrade_gear', 1); // Assuming forging counts as 'upgrade_gear'
        get().checkAllAchievements();
        return true;
    },
    purchaseShopItem: (dealId) => { // из КОД2
        const state = get();
        const deal = state.dailyDeals.find(d => d.id === dealId);
        if (!deal) {
            console.error("Сделка не найдена в текущих dailyDeals:", dealId);
            return false;
        }
        if (state.dailyShopPurchases[dealId]) {
            console.warn("Товар уже куплен:", dealId);
            return false;
        }
        const currency = deal.currency;
        const price = deal.price;
        if (state[currency] < price) {
            alert(`Недостаточно ${currency}!`);
            return false;
        }
        if (deal.type === 'item') {
            get().addItemToInventory(deal.itemId, deal.quantity || 1); // Uses modified addItemToInventory
        } else if (deal.type === 'artifact_shard') {
            get().addArtifactShards(deal.itemId, deal.quantity || 1);
        }
        const currentShopFlag = state.booleanFlags.hasMadeShopPurchase;
        let flagUpdate = !currentShopFlag ? { booleanFlags: { ...state.booleanFlags, hasMadeShopPurchase: true } } : {};
        set((prevState) => ({
            [currency]: prevState[currency] - price,
            dailyShopPurchases: { ...prevState.dailyShopPurchases, [dealId]: true },
            ...flagUpdate
        }));
        // get().trackTaskEvent('purchase_item', 1); // No direct task in code1, consider adding if needed
        get().checkAllAchievements();
        return true;
    },
    setBooleanFlag: (flagName, value = true) => {
        if (get().booleanFlags[flagName] !== value) {
            set((state) => ({
                booleanFlags: { ...state.booleanFlags, [flagName]: value }
            }));
            get().checkAllAchievements();
        }
    },
    completeLevelAction: (chapterId, levelId, difficulty, chapterContextData) => { // из КОД2, добавлен trackTaskEvent
        const levelKey = `c${chapterId}_l${levelId}`;
        const currentCompletion = get().levelsCompleted[levelKey] || { normal: false, hard: false };
        let difficultyKey = difficulty?.toLowerCase() === 'hard' ? 'hard' : 'normal';
        let newLevelsCompleted = get().levelsCompleted;
        let needsUpdate = false;

        if (difficultyKey === 'normal' && !currentCompletion.normal) {
            newLevelsCompleted = {
                ...newLevelsCompleted,
                [levelKey]: { ...currentCompletion, normal: true }
            };
            needsUpdate = true;
        } else if (difficultyKey === 'hard' && !currentCompletion.hard) {
            newLevelsCompleted = {
                ...newLevelsCompleted,
                [levelKey]: { ...currentCompletion, normal: true, hard: true }
            };
            needsUpdate = true;
        }

        if (needsUpdate) {
            set({ levelsCompleted: newLevelsCompleted });
            get().trackTaskEvent('complete_level', 1);
            get().checkAllAchievements();
            if (chapterContextData?.isZoneBossChapter && chapterContextData?.currentZoneIdForThisChapter) {
                const levelsForThisChapter = chapterContextData.levels || [];
                if (get().isChapterCompleted(chapterId, levelsForThisChapter)) {
                    get().completeZone(chapterContextData.currentZoneIdForThisChapter);
                }
            }
        }
    },
    claimAchievementReward: (achievementId) => { // из КОД2 (полная реализация)
        const state = get();
        const currentStatuses = state.achievementsStatus;
        const status = currentStatuses[achievementId] || { completed: false, claimed: false, progress: 0 };
        const definition = achievementsData.find(ach => ach.id === achievementId);
        if (!definition) {
            console.error(`Achievement definition not found for ID: ${achievementId}`);
            return;
        }
        let isCompleted = status.completed;
        if (!isCompleted) {
            if (definition.condition.type === 'counter') {
                isCompleted = (state[definition.condition.stat] ?? 0) >= definition.condition.target;
            } else if (definition.condition.type === 'boolean') {
                isCompleted = state.booleanFlags[definition.condition.flag] === true;
            } else if (definition.condition.type === 'level_complete') {
                const levelKey = `c${definition.condition.chapterId}_l${definition.condition.levelId}`;
                const levelStatus = state.levelsCompleted[levelKey];
                isCompleted = !!(levelStatus && (levelStatus.normal || levelStatus.hard));
            }
        }
        if (!isCompleted || status.claimed) {
            return;
        }
        let newStateChanges = {
            achievementsStatus: { ...currentStatuses, [achievementId]: { ...status, completed: true, claimed: true } }
        };
        let finalGold = state.gold;
        let finalDiamonds = state.diamonds;
        let finalInventoryAdditions = [];
        let finalTotalGoldCollected = state.totalGoldCollected;
        if (definition.reward?.gold > 0) {
            finalGold += definition.reward.gold;
            finalTotalGoldCollected += definition.reward.gold;
        }
        if (definition.reward?.diamonds > 0) {
            finalDiamonds += definition.reward.diamonds;
        }
        if (definition.reward?.items?.length > 0) {
            definition.reward.items.forEach(rewardItem => {
                const itemBase = getItemById(rewardItem.itemId);
                if (itemBase) {
                    for (let i = 0; i < (rewardItem.quantity || 1); i++) {
                        const newItem = createItemInstance(itemBase);
                        if(newItem) finalInventoryAdditions.push(newItem);
                    }
                } else {
                    console.warn(`Item base not found for achievement reward: ${rewardItem.itemId}`);
                }
            });
        }
        const xpGained = definition.xpGain || 0;
        if (xpGained > 0) {
            let currentXp = state.achievementXp + xpGained;
            let currentLevel = state.achievementLevel;
            let xpNeededForNext = getXpNeededForLevel(currentLevel);
            let levelUpOccurred = false;
            let totalLevelUpRewardGold = 0;
            let totalLevelUpRewardDiamonds = 0;
            while (currentXp >= xpNeededForNext && xpNeededForNext !== Infinity) {
                levelUpOccurred = true;
                currentLevel++;
                const levelReward = ACHIEVEMENT_LEVEL_REWARDS[currentLevel];
                if (levelReward) {
                    if (levelReward.gold) totalLevelUpRewardGold += levelReward.gold;
                    if (levelReward.diamonds) totalLevelUpRewardDiamonds += levelReward.diamonds;
                }
                xpNeededForNext = getXpNeededForLevel(currentLevel);
            }
            finalGold += totalLevelUpRewardGold;
            finalDiamonds += totalLevelUpRewardDiamonds;
            if (totalLevelUpRewardGold > 0) finalTotalGoldCollected += totalLevelUpRewardGold;
            newStateChanges.achievementXp = currentXp;
            if (levelUpOccurred) {
                newStateChanges.achievementLevel = currentLevel;
            }
        }
        newStateChanges.gold = finalGold;
        newStateChanges.diamonds = finalDiamonds;
        newStateChanges.totalGoldCollected = finalTotalGoldCollected;
        set(prevState => ({
            ...newStateChanges,
            inventory: [...prevState.inventory, ...finalInventoryAdditions]
        }));
        get().checkAllAchievements();
    },
    checkAllAchievements: () => { // из КОД2
        const state = get();
        let changed = false;
        const currentStatuses = state.achievementsStatus;
        const newStatuses = { ...currentStatuses };
        let hasUnclaimed = false;
        for (const achDef of achievementsData) {
            const status = newStatuses[achDef.id] || { progress: 0, completed: false, claimed: false };
            if (status.claimed) {
                if(status.completed) hasUnclaimed = false;
                continue;
            }
            let isNowCompleted = status.completed;
            let currentProgress = status.progress;
            if (achDef.condition.type === 'counter') {
                currentProgress = state[achDef.condition.stat] ?? 0;
                isNowCompleted = currentProgress >= achDef.condition.target;
            } else if (achDef.condition.type === 'boolean') {
                isNowCompleted = state.booleanFlags[achDef.condition.flag] === true;
                currentProgress = isNowCompleted ? 1 : 0;
            } else if (achDef.condition.type === 'level_complete') {
                const levelKey = `c${achDef.condition.chapterId}_l${achDef.condition.levelId}`;
                const levelStatus = state.levelsCompleted[levelKey];
                isNowCompleted = !!(levelStatus && (levelStatus.normal || levelStatus.hard) );
                currentProgress = isNowCompleted ? 1 : 0;
            }
            if ((isNowCompleted && !status.completed) || (achDef.condition.type === 'counter' && currentProgress !== status.progress && !status.completed) ) {
                newStatuses[achDef.id] = { ...status, progress: currentProgress, completed: isNowCompleted };
                changed = true;
            }
            if (newStatuses[achDef.id]?.completed && !newStatuses[achDef.id]?.claimed) {
                hasUnclaimed = true;
            }
        }
        if (changed) {
            set({ achievementsStatus: newStatuses });
        }
        get().setHasClaimableRewardsIndicator(hasUnclaimed || get().checkIfAnyTaskOrAchievementIsClaimable()); // Ensure tasks are also checked
    },
    generateDailyDeals: () => { // из КОД2
        const itemPool = itemsDatabase
            .filter(item => item && DAILY_DEAL_RARITY_WEIGHTS[item.rarity.toLowerCase()] !== undefined)
            .map(item => ({ type: 'item', data: item, rarity: item.rarity }));
        const artifactsForShards = ALL_ARTIFACTS_ARRAY
            .filter(art => art && DAILY_DEAL_RARITY_WEIGHTS[art.rarity.toLowerCase()] !== undefined);
        const shardPool = artifactsForShards
            .map(artifact => ({ type: 'artifact_shard', data: artifact, rarity: artifact.rarity }));
        const combinedPool = [...itemPool, ...shardPool];
        if (combinedPool.length === 0) {
            console.error("Пул для ежедневных предложений пуст!");
            set({ dailyDeals: [], dailyDealsLastGenerated: Date.now(), dailyShopPurchases: {} });
            return;
        }
        const weightedPool = combinedPool.map(entry => {
            if (!entry || !entry.rarity || !entry.data) {
                console.warn("Некорректный entry в combinedPool:", entry);
                return null;
            }
            return {
                item: entry,
                weight: DAILY_DEAL_RARITY_WEIGHTS[entry.rarity.toLowerCase()] || 1
            };
        }).filter(Boolean);
        if (weightedPool.length === 0) {
            console.error("Weighted pool for daily deals is empty after filtering!");
            set({ dailyDeals: [], dailyDealsLastGenerated: Date.now(), dailyShopPurchases: {} });
            return;
        }
        const numberOfDeals = 6;
        const generatedDeals = [];
        const selectedItemIds = new Set();
        let currentWeightedPool = [...weightedPool];
        let iterations = 0;
        while (generatedDeals.length < numberOfDeals && currentWeightedPool.length > 0 && iterations < 1000) {
            iterations++;
            const selectedEntryWrapper = weightedRandom(currentWeightedPool);
             if (!selectedEntryWrapper || !selectedEntryWrapper.item || !selectedEntryWrapper.item.data) {
                const problemIndex = currentWeightedPool.findIndex(poolEntry => poolEntry === selectedEntryWrapper);
                if (problemIndex !== -1) {
                    currentWeightedPool.splice(problemIndex, 1);
                } else if (currentWeightedPool.length > 0) {
                    currentWeightedPool.splice(Math.floor(Math.random() * currentWeightedPool.length), 1);
                }
                continue;
            }
            const selectedEntry = selectedEntryWrapper.item;
            const selectedIndexInPool = currentWeightedPool.findIndex(poolEntry => poolEntry.item === selectedEntry);
            const uniqueKey = `${selectedEntry.type}_${selectedEntry.data.id}`;
            if (!selectedItemIds.has(uniqueKey)) {
                selectedItemIds.add(uniqueKey);
                let quantity = 1;
                let currency = (Math.random() < 0.7) ? 'gold' : 'diamonds';
                let price = 100;
                const rarityMultiplier = { common: 1, uncommon: 3, rare: 10, legendary: 30, mythic: 100 };
                if (selectedEntry.type === 'item') {
                    price = (selectedEntry.data.basePrice || 100) * (rarityMultiplier[selectedEntry.rarity.toLowerCase()] || 1);
                    quantity = 1;
                } else if (selectedEntry.type === 'artifact_shard') {
                    price = (selectedEntry.data.baseShardCost || 50) * (rarityMultiplier[selectedEntry.rarity.toLowerCase()] || 1);
                    quantity = Math.random() < 0.5 ? 3 : 5;
                    if (selectedEntry.rarity.toLowerCase() === 'rare' || selectedEntry.rarity.toLowerCase() === 'legendary' || selectedEntry.rarity.toLowerCase() === 'mythic') {
                        currency = 'diamonds';
                    }
                    price = Math.round(price * quantity / (currency === 'diamonds' ? 10 : 1));
                }
                price = Math.max(currency === 'diamonds' ? 1 : 10, Math.round(price * (0.8 + Math.random() * 0.4)));
                const dealId = `daily_${uniqueKey}_${Date.now()}_${generatedDeals.length}`;
                const newDealObject = {
                    id: dealId, type: selectedEntry.type, itemId: selectedEntry.data.id,
                    name: selectedEntry.data.name, icon: selectedEntry.data.image || selectedEntry.data.icon,
                    quantity: quantity, currency: currency, price: price, rarity: selectedEntry.rarity,
                    discount: 0, purchaseLimit: 1,
                };
                generatedDeals.push(newDealObject);
            }
            if (selectedIndexInPool !== -1) {
                currentWeightedPool.splice(selectedIndexInPool, 1);
            } else {
                if (currentWeightedPool.length > 0) currentWeightedPool.shift();
            }
             if (currentWeightedPool.length === 0 && generatedDeals.length < numberOfDeals) {
                break;
            }
        }
         if (iterations >= 999) {
            console.error("[generateDailyDeals] Превышено максимальное количество итераций!");
        }
        set({
            dailyDeals: generatedDeals,
            dailyDealsLastGenerated: Date.now(),
            dailyShopPurchases: {}
        });
    },
    checkAndRefreshDailyDeals: () => { // из КОД2
        const state = get();
        const lastGeneratedTs = state.dailyDealsLastGenerated;
        const nowTs = Date.now();
        if (!lastGeneratedTs) {
            get().generateDailyDeals();
            return;
        }
        const nowUtcDate = new Date(nowTs);
        const targetTodayUtcTs = Date.UTC(
            nowUtcDate.getUTCFullYear(), nowUtcDate.getUTCMonth(), nowUtcDate.getUTCDate(),
            REFRESH_HOUR_UTC, 0, 0, 0
        );
        let lastRefreshMarkerTs;
        if (nowTs >= targetTodayUtcTs) {
            lastRefreshMarkerTs = targetTodayUtcTs;
        } else {
            const targetYesterdayUtcTs = Date.UTC(
                nowUtcDate.getUTCFullYear(), nowUtcDate.getUTCMonth(), nowUtcDate.getUTCDate() - 1,
                REFRESH_HOUR_UTC, 0, 0, 0
            );
            lastRefreshMarkerTs = targetYesterdayUtcTs;
        }
        if (lastGeneratedTs < lastRefreshMarkerTs) {
            get().generateDailyDeals();
        } else {
            if (state.dailyDeals.length === 0 && savedState.dailyDeals && savedState.dailyDeals.length > 0) {
                 set({ dailyDeals: savedState.dailyDeals, dailyShopPurchases: savedState.dailyShopPurchases || {} });
            } else if (state.dailyDeals.length === 0) {
                // console.log("Daily deals are empty, but refresh time not yet passed.");
            }
        }
    },
    collectArtifact: (artifactId) => { // из КОД2
        const artifactData = getArtifactById(artifactId);
        if (!artifactData) {
            console.warn(`Artifact data not found for ID: ${artifactId}`);
            return;
        }
        set((state) => {
            if (state.collectedArtifacts.has(artifactId)) {
                return {};
            }
            const newCollected = new Set(state.collectedArtifacts);
            newCollected.add(artifactId);
            const newLevels = { ...state.artifactLevels };
            if (!newLevels[artifactId]) {
                newLevels[artifactId] = { level: 0, shards: 0 };
            }
            return {
                collectedArtifacts: newCollected,
                artifactLevels: newLevels,
            };
        });
        get().updatePowerLevel();
        get().checkAllAchievements();
    },
    addArtifactShards: (artifactId, amount) => { // из КОД2
        if (amount <= 0) return;
        const artifactData = getArtifactById(artifactId);
        if (!artifactData) {
            console.warn(`Попытка добавить осколки для несуществующего артефакта: ${artifactId}`);
            return;
        }
        set((state) => {
            const currentInfo = state.artifactLevels[artifactId] || { level: 0, shards: 0 };
            let newCollectedArtifacts = state.collectedArtifacts;
            if (!state.collectedArtifacts.has(artifactId)) {
                newCollectedArtifacts = new Set(state.collectedArtifacts);
                newCollectedArtifacts.add(artifactId);
            }
            const newShards = currentInfo.shards + amount;
            return {
                artifactLevels: {
                    ...state.artifactLevels,
                    [artifactId]: { ...currentInfo, shards: newShards }
                },
                ...(newCollectedArtifacts !== state.collectedArtifacts && { collectedArtifacts: newCollectedArtifacts })
            };
        });
    },
    activateArtifact: (artifactId) => { // из КОД2
        const artifactData = getArtifactById(artifactId);
        if (!artifactData) { console.error("Арт не найден:", artifactId); return; }
        set((state) => {
            const currentInfo = state.artifactLevels[artifactId] || { level: 0, shards: 0 };
            if (currentInfo.level !== 0) {
                console.warn(`Попытка активировать уже активный/улучшенный (${currentInfo.level}) артефакт: ${artifactId}`);
                return {};
            }
            const shardsNeeded = (0 + 1) * (artifactData.baseShardCost || BASE_SHARD_COST_PER_LEVEL[artifactData.rarity.toLowerCase()] || 10);
            if (currentInfo.shards < shardsNeeded) {
                return {};
            }
            const remainingShards = currentInfo.shards - shardsNeeded;
            const newCollected = new Set(state.collectedArtifacts);
            newCollected.add(artifactId);
            return {
                collectedArtifacts: newCollected,
                artifactLevels: {
                    ...state.artifactLevels,
                    [artifactId]: { level: 1, shards: remainingShards }
                }
            };
        });
        get().updatePowerLevel();
        get().checkAllAchievements();
        get().initializeLevelHp();
    },
    upgradeArtifact: (artifactId) => { // из КОД2
        const artifactData = getArtifactById(artifactId);
        if (!artifactData) { console.error("Арт не найден:", artifactId); return; }
        set((state) => {
            const currentInfo = state.artifactLevels[artifactId];
            if (!currentInfo || currentInfo.level === 0) {
                console.warn(`Попытка улучшить неактивированный или несуществующий артефакт: ${artifactId}`);
                return {};
            }
            const currentLevel = currentInfo.level;
            const maxLevel = artifactData.maxLevel || MAX_ARTIFACT_LEVEL;
            if (currentLevel >= maxLevel) {
                return {};
            }
            const shardsNeeded = (currentLevel + 1) * (artifactData.baseShardCost || BASE_SHARD_COST_PER_LEVEL[artifactData.rarity.toLowerCase()] || 10);
            if (currentInfo.shards < shardsNeeded) {
                return {};
            }
            const newLevel = currentLevel + 1;
            const remainingShards = currentInfo.shards - shardsNeeded;
            return {
                artifactLevels: {
                    ...state.artifactLevels,
                    [artifactId]: { level: newLevel, shards: remainingShards }
                }
            };
        });
        get().updatePowerLevel();
        get().checkAllAchievements();
        get().initializeLevelHp();
    },
    updatePowerLevel: () => { // из КОД2
        const { equipped, artifactLevels, collectedArtifacts } = get();
        let totalPower = 0;
        Object.values(equipped).filter(Boolean).forEach(item => {
            const itemLevel = item?.currentLevel || 0;
            const basePower = item?.basePowerLevel || 0;
            const powerPerLvl = item?.powerPerLevel || 0;
            const currentItemPower = basePower + (powerPerLvl * itemLevel);
            totalPower += Math.round(currentItemPower);
        });
        for (const artifactId in artifactLevels) {
            if (collectedArtifacts.has(artifactId)) {
                const level = artifactLevels[artifactId]?.level || 0;
                if (level > 0) {
                    const artifactData = getArtifactById(artifactId);
                    if (artifactData) {
                        const artifactBasePower = artifactData.basePowerLevel || 0;
                        const artifactPowerPerLevel = artifactData.powerLevelPerLevel || 0;
                        const currentArtifactPower = artifactBasePower + (artifactPowerPerLevel * (level -1) );
                        totalPower += Math.round(currentArtifactPower);
                    } else {
                        console.warn(`Данные для артефакта ${artifactId} не найдены при расчете PL.`);
                    }
                }
            }
        }
        const finalPowerLevel = Math.max(0, totalPower);
        if (get().powerLevel !== finalPowerLevel) {
           set({ powerLevel: finalPowerLevel });
        }
    },
    addItemToInventoryLogic: (currentInventory, itemData) => { // из КОД2
        const newItemInstance = createItemInstance(itemData);
        if(!newItemInstance) return currentInventory;
        return [...currentInventory, newItemInstance];
    },
    openGearChest: (chestId) => { // из КОД2, добавлен trackTaskEvent
        const state = get();
        const chestData = getGearChestById(chestId);
        if (!chestData) {
            console.error(`[GearChest] Сундук с ID ${chestId} не найден в gearChestData.js.`);
            return;
        }
        const cost = chestData.cost;
        if (state[cost.currency] < cost.price) {
            alert(`Недостаточно ${cost.currency}! Нужно ${cost.price}`);
            return;
        }
        const currentPity = state.gearChestPity[chestId] || {};
        let nextPity = { ...currentPity };
        let guaranteedRarity = null;
        let finalRarity = null;
        if (chestData.pity) {
            const pityConfigs = Array.isArray(chestData.pity) ? chestData.pity : [chestData.pity];
            pityConfigs.forEach(p => {
                const key = p.rarity.toLowerCase();
                nextPity[key] = (nextPity[key] || 0) + 1;
            });
            const epicPityConfig = pityConfigs.find(p => p.rarity === 'Epic');
            if (epicPityConfig && nextPity.epic >= epicPityConfig.limit) {
                guaranteedRarity = 'Epic';
            } else {
                const rarePityConfig = pityConfigs.find(p => p.rarity === 'Rare');
                if (rarePityConfig && nextPity.rare >= rarePityConfig.limit) {
                    guaranteedRarity = 'Rare';
                }
            }
        }
        if (guaranteedRarity) {
            finalRarity = guaranteedRarity;
        } else {
            finalRarity = _rollWeightedRarity_Gear(chestData.rarityChances);
        }
        const obtainedItemData = _selectRandomGearItemByRarity_Gear(finalRarity);
        if (!obtainedItemData) {
            console.error(`[GearChest] Не удалось получить предмет редкости ${finalRarity}. Отмена.`);
            return;
        }
        const obtainedRarity = obtainedItemData.rarity;
        if (chestData.pity) {
            const pityConfigs = Array.isArray(chestData.pity) ? chestData.pity : [chestData.pity];
            if (obtainedRarity === 'Epic' && pityConfigs.some(p => p.rarity === 'Epic')) {
                nextPity.epic = 0;
                if (pityConfigs.some(p => p.rarity === 'Rare')) nextPity.rare = 0;
            } else if (obtainedRarity === 'Rare' && pityConfigs.some(p => p.rarity === 'Rare')) {
                nextPity.rare = 0;
            }
        }
        const rewardDetails = {
            type: 'gear', id: obtainedItemData.id, name: obtainedItemData.name,
            icon: obtainedItemData.image, rarity: obtainedItemData.rarity, amount: 1,
        };
        set(prevState => {
            if (!prevState) {
                console.error("[GearChest] prevState is undefined in set function!");
                return {};
            }
            return {
                [cost.currency]: prevState[cost.currency] - cost.price,
                totalGearChestsOpened: prevState.totalGearChestsOpened + 1,
                gearChestPity: {
                    ...prevState.gearChestPity,
                    [chestId]: nextPity
                },
                inventory: get().addItemToInventoryLogic(prevState.inventory, obtainedItemData), // Use modified addItemToInventoryLogic
                lastOpenedChestInfo: { chestId: chestId, amount: 1, type: 'gear', name: chestData.name },
                lastChestRewards: [rewardDetails]
            };
        });
        get().trackTaskEvent('open_chest', 1);
        get().checkAllAchievements();
    },
    openGearChestX10: (chestId) => { // из КОД2, добавлен trackTaskEvent
        const state = get();
        const chestData = getGearChestById(chestId);
        if (!chestData) {
            console.error(`[GearChestX10] Сундук с ID ${chestId} не найден.`);
            return;
        }
        const cost = chestData.cost;
        const totalCost = cost.price * 10;
        if (state[cost.currency] < totalCost) {
            alert(`Недостаточно ${cost.currency}! Нужно ${totalCost}`);
            return;
        }
        let workingPity = { ...(state.gearChestPity[chestId] || {}) };
        const rewardsDetailed = [];
        const newItemInstances = [];
        for (let i = 0; i < 10; i++) {
            let guaranteedRarity = null;
            let finalRarity = null;
            if (chestData.pity) {
                const pityConfigs = Array.isArray(chestData.pity) ? chestData.pity : [chestData.pity];
                pityConfigs.forEach(p => {
                    const key = p.rarity.toLowerCase();
                    workingPity[key] = (workingPity[key] || 0) + 1;
                });
                const epicPityConfig = pityConfigs.find(p => p.rarity === 'Epic');
                if (epicPityConfig && workingPity.epic >= epicPityConfig.limit) {
                    guaranteedRarity = 'Epic';
                } else {
                    const rarePityConfig = pityConfigs.find(p => p.rarity === 'Rare');
                    if (rarePityConfig && workingPity.rare >= rarePityConfig.limit) {
                        guaranteedRarity = 'Rare';
                    }
                }
            }
            if (guaranteedRarity) {
                finalRarity = guaranteedRarity;
            } else {
                finalRarity = _rollWeightedRarity_Gear(chestData.rarityChances);
            }
            const obtainedItemData = _selectRandomGearItemByRarity_Gear(finalRarity);
            if (!obtainedItemData) {
                console.error(`  [Pull ${i + 1}] Не удалось получить предмет редкости ${finalRarity}! Пропускаем.`);
                rewardsDetailed.push({ type: 'error', name: `Ошибка получения ${finalRarity}` });
                continue;
            }
            const obtainedRarity = obtainedItemData.rarity;
            if (chestData.pity) {
                const pityConfigs = Array.isArray(chestData.pity) ? chestData.pity : [chestData.pity];
                 if (obtainedRarity === 'Epic' && pityConfigs.some(p => p.rarity === 'Epic')) {
                    workingPity.epic = 0;
                    if (pityConfigs.some(p => p.rarity === 'Rare')) workingPity.rare = 0;
                } else if (obtainedRarity === 'Rare' && pityConfigs.some(p => p.rarity === 'Rare')) {
                    workingPity.rare = 0;
                }
            }
            const rewardDetails = { type: 'gear', ...obtainedItemData, amount: 1, icon: obtainedItemData.image };
            rewardsDetailed.push(rewardDetails);
            const newItem = createItemInstance(obtainedItemData);
            if(newItem) newItemInstances.push(newItem);
        }
        set(prevState => {
            if (!prevState) return {};
            return {
                [cost.currency]: prevState[cost.currency] - totalCost,
                totalGearChestsOpened: prevState.totalGearChestsOpened + 10,
                gearChestPity: {
                    ...prevState.gearChestPity,
                    [chestId]: workingPity
                },
                inventory: [...prevState.inventory, ...newItemInstances],
                lastOpenedChestInfo: { chestId: chestId, amount: 10, type: 'gear', name: chestData.name },
                lastChestRewards: rewardsDetailed
            };
        });
        get().trackTaskEvent('open_chest', 10);
        get().checkAllAchievements();
    },
    processArtifactReward: (dropType, targetArtifactId) => { // из КОД2
        if (!targetArtifactId) return { details: null, obtainedFullArtifact: false };
        const artifactData = getArtifactById(targetArtifactId);
        if (!artifactData) { console.error(`[ProcessArtifact] Data not found for ${targetArtifactId}`); return { details: null, obtainedFullArtifact: false }; }
        let rewardDetails = null;
        let obtainedFullArtifact = false;
        if (dropType === 'artifact_shard') {
            const amount = 1;
            get().addArtifactShards(targetArtifactId, amount);
            rewardDetails = { type: 'artifact_shard', amount, artifactId: targetArtifactId, icon: artifactData.icon, name: `${artifactData.name} (осколок)`, rarity: artifactData.rarity };
        }
        else if (dropType === 'full_artifact') {
            obtainedFullArtifact = true;
            const currentArtifactState = get().artifactLevels[targetArtifactId];
            const isCollected = get().collectedArtifacts.has(targetArtifactId);
            const isActive = isCollected && currentArtifactState && currentArtifactState.level > 0;
            const shardAmountOnDuplicate = artifactData.shardValueOnDuplicate || 10;
            if (isActive) {
                get().addArtifactShards(targetArtifactId, shardAmountOnDuplicate);
                rewardDetails = { type: 'full_artifact_duplicate', artifactId: targetArtifactId, isNew: false, shardAmount: shardAmountOnDuplicate, icon: artifactData.icon, name: artifactData.name, rarity: artifactData.rarity };
            } else {
                if (!isCollected) {
                    get().collectArtifact(targetArtifactId);
                }
                set(state => {
                     const newCollected = new Set(state.collectedArtifacts);
                     newCollected.add(targetArtifactId);
                     return {
                         collectedArtifacts: newCollected,
                         artifactLevels: {
                             ...state.artifactLevels,
                             [targetArtifactId]: {
                                 shards: (state.artifactLevels[targetArtifactId]?.shards || 0),
                                 level: 1,
                             }
                         }
                     };
                });
                get().updatePowerLevel();
                rewardDetails = { type: 'full_artifact_new', artifactId: targetArtifactId, isNew: true, icon: artifactData.icon, name: artifactData.name, rarity: artifactData.rarity };
            }
        } else {
            console.warn("Unknown dropType in processArtifactReward:", dropType);
        }
        return { details: rewardDetails, obtainedFullArtifact: obtainedFullArtifact };
    },
    openArtifactChest: (chestId) => { // из КОД2, добавлен trackTaskEvent
        const state = get();
        const chestData = getArtifactChestById(chestId);
        if (!chestData || !chestData.isEnabled) { console.error(`Сундук ${chestId} не найден или не активен.`); return; }
        if (state[chestData.cost.currency] < chestData.cost.price) { alert(`Недостаточно ${chestData.cost.currency}!`); return; }
        let currentPity = state.artifactChestPity[chestId] || 0;
        currentPity++;
        const newTotalOpened = state.totalArtifactChestsOpened + 1;
        let rewardTypeObj = null;
        let obtainedFullArtifactDueToPity = false;
        if (currentPity >= chestData.pityLimit) {
            rewardTypeObj = chestData.rewardPool.find(r => r.type === 'full_artifact');
            if (rewardTypeObj) obtainedFullArtifactDueToPity = true;
            else {
                console.warn(`Pity hit for ${chestId}, but 'full_artifact' type not in pool. Rolling normally.`);
                rewardTypeObj = selectWeightedRewardType(chestData.rewardPool);
            }
        } else {
            rewardTypeObj = selectWeightedRewardType(chestData.rewardPool);
        }
        if (!rewardTypeObj) { console.error("Не удалось определить тип награды."); return; }
        const rewardType = rewardTypeObj.type;
        let rewardProcessingResult = { details: null, obtainedFullArtifact: obtainedFullArtifactDueToPity };
        if (rewardType === 'gold') {
            const amount = Math.floor(Math.random() * (rewardTypeObj.max - rewardTypeObj.min + 1)) + rewardTypeObj.min;
            get().addGold(amount); // Uses modified addGold
            rewardProcessingResult.details = { type: 'gold', amount, icon: '/assets/icons/currency/gold.png', name: 'Золото' };
        } else if (rewardType === 'diamonds') {
            const amount = rewardTypeObj.amount;
            get().addDiamonds(amount); // Uses modified addDiamonds
            rewardProcessingResult.details = { type: 'diamonds', amount, icon: '/assets/icons/currency/diamond.png', name: 'Алмазы' };
        } else if (rewardType === 'artifact_shard' || rewardType === 'full_artifact') {
            const targetArtifactId = _selectWeightedArtifactIdFromSet_ByRarity(chestData.setId);
            if (!targetArtifactId) { console.error("Не удалось выбрать артефакт из сета."); return; }
            const typeToProcess = obtainedFullArtifactDueToPity ? 'full_artifact' : rewardType;
            rewardProcessingResult = get().processArtifactReward(typeToProcess, targetArtifactId);
        } else {
            console.warn(`Неизвестный тип награды из пула: ${rewardType}`);
        }
        let finalPityValue = currentPity;
        if (rewardProcessingResult.obtainedFullArtifact || obtainedFullArtifactDueToPity) {
            finalPityValue = 0;
        }
        set((prevState) => {
            if (!prevState) return {};
            return {
                [chestData.cost.currency]: prevState[chestData.cost.currency] - chestData.cost.price,
                artifactChestPity: { ...prevState.artifactChestPity, [chestId]: finalPityValue },
                totalArtifactChestsOpened: newTotalOpened,
                lastOpenedChestInfo: { chestId: chestId, amount: 1, type: 'artifact', name: chestData.name },
                lastChestRewards: rewardProcessingResult.details ? [rewardProcessingResult.details] : [],
            };
        });
        get().trackTaskEvent('open_chest', 1);
        get().checkAllAchievements();
        if(rewardProcessingResult.obtainedFullArtifact || rewardType === 'artifact_shard'){
            get().initializeLevelHp();
        }
    },
    openArtifactChestX10: (chestId) => { // из КОД2, добавлен trackTaskEvent
        const state = get();
        const chestData = getArtifactChestById(chestId);
        if (!chestData || !chestData.isEnabled) { console.error(`Сундук ${chestId} не найден или не активен.`); return; }
        const totalCost = chestData.cost.price * 10;
        if (state[chestData.cost.currency] < totalCost) { alert(`Недостаточно ${chestData.cost.currency}!`); return; }
        let workingPity = state.artifactChestPity[chestId] || 0;
        const newTotalOpened = state.totalArtifactChestsOpened + 10;
        const rewardsDetailed = [];
        let hasObtainedAnyArtifactMaterialInBatch = false;
        for (let i = 0; i < 10; i++) {
            workingPity++;
            let rewardTypeObj = null;
            let obtainedFullArtifactThisPull = false;
            if (workingPity >= chestData.pityLimit) {
                rewardTypeObj = chestData.rewardPool.find(r => r.type === 'full_artifact');
                if (rewardTypeObj) obtainedFullArtifactThisPull = true;
                else rewardTypeObj = selectWeightedRewardType(chestData.rewardPool);
            } else {
                rewardTypeObj = selectWeightedRewardType(chestData.rewardPool);
            }
            if (!rewardTypeObj) { console.error(`[X10 Pull ${i+1}] Failed type roll!`); rewardsDetailed.push({ type: 'error', name: 'Ошибка ролла типа' }); continue; }
            const rewardType = rewardTypeObj.type;
            let currentPullProcessingResult = { details: null, obtainedFullArtifact: obtainedFullArtifactThisPull };
            if (rewardType === 'gold') {
                const amount = Math.floor(Math.random() * (rewardTypeObj.max - rewardTypeObj.min + 1)) + rewardTypeObj.min;
                get().addGold(amount); // Uses modified addGold
                currentPullProcessingResult.details = { type: 'gold', amount, icon: '/assets/icons/currency/gold.png', name: 'Золото' };
            } else if (rewardType === 'diamonds') {
                const amount = rewardTypeObj.amount;
                get().addDiamonds(amount); // Uses modified addDiamonds
                currentPullProcessingResult.details = { type: 'diamonds', amount, icon: '/assets/icons/currency/diamond.png', name: 'Алмазы' };
            } else if (rewardType === 'artifact_shard' || rewardType === 'full_artifact') {
                const targetArtifactId = _selectWeightedArtifactIdFromSet_ByRarity(chestData.setId);
                if (!targetArtifactId) { console.error(`[X10 Pull ${i+1}] Failed artifact selection!`); rewardsDetailed.push({ type: 'error', name: 'Ошибка выбора артефакта' }); continue; }
                const typeToProcess = obtainedFullArtifactThisPull ? 'full_artifact' : rewardType;
                currentPullProcessingResult = get().processArtifactReward(typeToProcess, targetArtifactId);
                if(currentPullProcessingResult.obtainedFullArtifact || rewardType === 'artifact_shard') hasObtainedAnyArtifactMaterialInBatch = true;
            } else {
                 console.warn(`[X10 Pull ${i+1}] Unknown type: ${rewardType}`);
                 currentPullProcessingResult.details = { type: 'error', name: `Неизвестный тип ${rewardType}` };
            }
            if (currentPullProcessingResult.details) {
                rewardsDetailed.push(currentPullProcessingResult.details);
            } else {
                rewardsDetailed.push({ type: 'error', name: 'Ошибка обработки награды' });
            }
            if (currentPullProcessingResult.obtainedFullArtifact) {
                workingPity = 0;
            }
        }
        set((prevState) => ({
            [chestData.cost.currency]: prevState[chestData.cost.currency] - totalCost,
            artifactChestPity: { ...prevState.artifactChestPity, [chestId]: workingPity },
            totalArtifactChestsOpened: newTotalOpened,
            lastOpenedChestInfo: { chestId: chestId, amount: 10, type: 'artifact', name: chestData.name },
            lastChestRewards: rewardsDetailed,
        }));
        get().trackTaskEvent('open_chest', 10);
        get().checkAllAchievements();
        if(hasObtainedAnyArtifactMaterialInBatch){
            get().initializeLevelHp();
        }
    },
    clearLastChestData: () => set({ lastChestRewards: null, lastOpenedChestInfo: null }),
    resetLevelRewards: () => { set({ currentLevelRewards: { gold: 0, diamonds: 0, items: [] } }); },
    addLevelReward: (type, amountOrItem) => { // из КОД2
        if (!type || amountOrItem === undefined || amountOrItem === null) return;
        if ((type === 'gold' || type === 'diamonds') && typeof amountOrItem === 'number' && amountOrItem > 0) {
            set((state) => {
                const currentAmount = state.currentLevelRewards[type] || 0;
                const newAmount = currentAmount + amountOrItem;
                return {
                    currentLevelRewards: { ...state.currentLevelRewards, [type]: newAmount }
                };
            });
        }
        else if (type === 'item' && typeof amountOrItem === 'object' && amountOrItem.id) {
           const itemInfo = {
                id: amountOrItem.id, name: amountOrItem.name || 'Предмет',
                rarity: amountOrItem.rarity || 'Common',
                icon: amountOrItem.image || amountOrItem.icon || '/assets/icons/item_default.png'
            };
            set((state) => ({
                currentLevelRewards: {
                    ...state.currentLevelRewards,
                    items: [...state.currentLevelRewards.items, itemInfo],
                }
            }));
        } else {
            console.warn(`[addLevelReward] Неверный тип или значение: ${type}`, amountOrItem);
        }
    },
    openLevelChest: (chestInstanceId, chestTypeId) => { // из КОД2, добавлен trackTaskEvent
        const state = get();
        if (state.levelChestStates[chestInstanceId]) {
            return;
        }
        const chestTypeData = getLevelChestTypeById(chestTypeId);
        if (!chestTypeData) {
            console.error(`[openLevelChest] Не найдены данные для типа сундука: ${chestTypeId}`);
            return;
        }
        const lootTable = chestTypeData.lootTable;
        const generatedRewardsForPopup = [];
        let collectedGoldThisChest = 0;
        let collectedDiamondsThisChest = 0;
        lootTable.guaranteed?.forEach(rewardEntry => {
            if (rewardEntry.type === 'gold' || rewardEntry.type === 'diamonds') {
                const amount = Math.floor(Math.random() * (rewardEntry.max - rewardEntry.min + 1)) + rewardEntry.min;
                if (amount > 0) {
                    if (rewardEntry.type === 'gold') {
                        get().addGold(amount); // Uses modified addGold
                        collectedGoldThisChest += amount;
                    }
                    if (rewardEntry.type === 'diamonds') {
                        get().addDiamonds(amount); // Uses modified addDiamonds
                        collectedDiamondsThisChest += amount;
                    }
                    generatedRewardsForPopup.push({
                        type: rewardEntry.type, amount: amount,
                        name: rewardEntry.type === 'gold' ? 'Золото' : 'Алмазы',
                        icon: rewardEntry.type === 'gold' ? '/assets/icons/currency/gold.png' : '/assets/icons/currency/diamond.png'
                    });
                }
            }
        });
        if (collectedGoldThisChest > 0) get().addLevelReward('gold', collectedGoldThisChest);
        if (collectedDiamondsThisChest > 0) get().addLevelReward('diamonds', collectedDiamondsThisChest);
        if (lootTable.itemDrop && Math.random() < (lootTable.itemDrop.chance || 1.0)) {
            const rarityChances = lootTable.itemDrop.rarityChances;
            try {
                const chosenRarity = _rollWeightedRarity_Gear(rarityChances);
                const itemTemplate = _selectRandomGearItemByRarity_Gear(chosenRarity);
                if (itemTemplate) {
                    get().addItemToInventory(itemTemplate.id, 1); // Uses modified addItemToInventory
                    const itemRewardInfo = {
                        type: 'item', id: itemTemplate.id, name: itemTemplate.name,
                        rarity: itemTemplate.rarity, icon: itemTemplate.image
                    };
                    generatedRewardsForPopup.push(itemRewardInfo);
                    get().addLevelReward('item', itemTemplate);
                } else {
                    console.warn(`  - [Loot] Не удалось выбрать предмет редкости ${chosenRarity} для сундука уровня.`);
                }
            } catch (e) {
                console.error("Ошибка при генерации предмета из сундука уровня:", e);
            }
        }
        set({
            lastOpenedLevelChestRewards: generatedRewardsForPopup,
            levelChestStates: { ...get().levelChestStates, [chestInstanceId]: true }
        });
        get().trackTaskEvent('open_chest', 1);
        const popupDuration = 4000;
        setTimeout(() => {
            get().clearLastLevelChestRewards();
        }, popupDuration);
    },
    clearLastLevelChestRewards: () => { // из КОД2
        if (get().lastOpenedLevelChestRewards !== null) {
            set({ lastOpenedLevelChestRewards: null });
        }
    },
    addDebuff: (debuff) => { // из КОД2
        const newDebuff = {
            ...debuff,
            id: debuff.id || uuidv4(),
            endTime: Date.now() + debuff.durationMs,
        };
        set(state => ({
            activeDebuffs: [...state.activeDebuffs, newDebuff]
        }));
        get().updatePowerLevel();
        get().initializeLevelHp();
    },
    removeDebuff: (debuffId) => { // из КОД2
        let changed = false;
        set(state => {
            const newDebuffs = state.activeDebuffs.filter(d => d.id !== debuffId);
            if (newDebuffs.length !== state.activeDebuffs.length) changed = true;
            return { activeDebuffs: newDebuffs };
        });
        if (changed) {
            get().updatePowerLevel();
            get().initializeLevelHp();
        }
    },
    clearExpiredDebuffs: () => { // из КОД2
        const now = Date.now();
        const currentDebuffs = get().activeDebuffs;
        const activeDebuffs = currentDebuffs.filter(debuff => now < debuff.endTime);
        if (activeDebuffs.length < currentDebuffs.length) {
            set({ activeDebuffs });
            get().updatePowerLevel();
            get().initializeLevelHp();
        }
    },
    setWeakeningAuraStatus: (isActive) => { // из КОД2
        if (get().isAffectedByWeakeningAura !== isActive) {
            set({ isAffectedByWeakeningAura: isActive });
            get().initializeLevelHp();
            get().updatePowerLevel();
        }
    },
    isZoneUnlocked: (zoneId) => { // из КОД2
        const zoneConfig = ALL_ZONES_CONFIG.find(z => z.id === zoneId);
        if (!zoneConfig) {
            console.warn(`[useGameStore] isZoneUnlocked: Конфигурация для зоны ${zoneId} не найдена.`);
            return false;
        }
        if (ALL_ZONES_CONFIG[0]?.id === zoneId || !zoneConfig.unlockCondition) {
            return true;
        }
        const { type, requiredZoneId } = zoneConfig.unlockCondition;
        if (type === 'zone_completed') {
            if (!requiredZoneId) {
                console.warn(`[useGameStore] isZoneUnlocked: Для зоны ${zoneId} условие 'zone_completed' не имеет requiredZoneId.`);
                return false;
            }
            return !!get().completedZones[requiredZoneId];
        }
        return false;
    },
    completeZone: (zoneId) => { // из КОД2
        const zoneConfig = ALL_ZONES_CONFIG.find(z => z.id === zoneId);
        if (!zoneConfig) {
            console.warn(`[useGameStore] completeZone: Конфигурация для зоны ${zoneId} не найдена.`);
            return;
        }
        if (get().completedZones[zoneId]) {
            return;
        }
        set(state => ({
            completedZones: {
                ...state.completedZones,
                [zoneId]: true,
            }
        }));
        console.log(`[useGameStore] Зона ${zoneConfig.name || zoneId} отмечена как пройденная.`);
        get().checkAllAchievements();
    },
    getLevelCompletionStatus: (chapterId, levelId) => { // из КОД2
        const levelKey = `c${chapterId}_l${levelId}`;
        return get().levelsCompleted[levelKey] || { normal: false, hard: false };
    },
    isChapterCompleted: (chapterId, allLevelsInChapter) => { // из КОД2
        if (!allLevelsInChapter || allLevelsInChapter.length === 0) {
            return false;
        }
        for (const level of allLevelsInChapter) {
            const levelKey = `c${chapterId}_l${level.id}`;
            const status = get().levelsCompleted[levelKey];
            if (!status || !status.normal) {
                return false;
            }
        }
        return true;
    },
    isLevelUnlocked: (chapterId, levelId, allLevelsInChapter, allLevelsInPrevChapter = null, prevChapterId = null) => { // из КОД2
        if (!allLevelsInChapter || allLevelsInChapter.length === 0) return false;
        const levelIndex = allLevelsInChapter.findIndex(l => l.id === levelId);
        if (levelIndex === -1) return false;
        if (chapterId === INITIAL_CHAPTER_ID && levelIndex === 0) {
            return true;
        }
        if (levelIndex > 0) {
            const prevLevelInChapter = allLevelsInChapter[levelIndex - 1];
            const prevLevelKey = `c${chapterId}_l${prevLevelInChapter.id}`;
            const prevLevelStatus = get().levelsCompleted[prevLevelKey];
            return !!(prevLevelStatus && prevLevelStatus.normal);
        }
        if (levelIndex === 0 && chapterId !== INITIAL_CHAPTER_ID) {
            if (allLevelsInPrevChapter && prevChapterId !== null) {
                return get().isChapterCompleted(prevChapterId, allLevelsInPrevChapter);
            }
            return false;
        }
        return false;
    },
    isHardModeUnlocked: (chapterId, levelId) => { // из КОД2
        const levelKey = `c${chapterId}_l${levelId}`;
        const status = get().levelsCompleted[levelKey];
        return !!(status && status.normal);
    },
    setIsFullScreenMapActive: (isActive) => { // из КОД2
        set({ isFullScreenMapActive: isActive });
    },
    startScreenTransition: (navigationOrContentChangeCallback, postOpenCallback = null) => { // из КОД2
        if (get().isScreenTransitioning && get().transitionAction === 'closing') {
            return;
        }
        set({
            isScreenTransitioning: true,
            transitionAction: 'closing',
            onTransitionOpenCompleteCallback: null,
            onTransitionCloseCompleteCallback: () => {
                if (navigationOrContentChangeCallback) {
                    navigationOrContentChangeCallback();
                }
                setTimeout(() => {
                    set({
                        transitionAction: 'opening',
                        onTransitionCloseCompleteCallback: null,
                        onTransitionOpenCompleteCallback: () => {
                            if (postOpenCallback) {
                                postOpenCallback();
                            }
                            set({
                                isScreenTransitioning: false,
                                transitionAction: null,
                                onTransitionOpenCompleteCallback: null
                            });
                        }
                    });
                }, 50);
            }
        });
    },
    ensureScreenIsOpening: (postOpenCallback = null) => { // из КОД2
        const state = get();
        if (!state.isScreenTransitioning || state.transitionAction !== 'opening') {
            set({
                isScreenTransitioning: true,
                transitionAction: 'opening',
                onTransitionCloseCompleteCallback: null,
                onTransitionOpenCompleteCallback: () => {
                    if (postOpenCallback) postOpenCallback();
                    set({
                        isScreenTransitioning: false,
                        transitionAction: null,
                        onTransitionOpenCompleteCallback: null
                    });
                }
            });
        }
    },
    setCurrentChapter: (chapterId) => { // из КОД2
        set({ currentChapterId: chapterId });
    },
    setHasClaimableRewardsIndicator: (hasRewards) => { // из КОД2 (но логика в checkAllAchievements и claim обновляет)
        if (get().hasClaimableRewardsIndicator !== hasRewards) {
            set({ hasClaimableRewardsIndicator: hasRewards });
        }
    },
    checkAndResetTreasureChestAttempts: () => set((state) => { // из КОД2
        const nowTs = Date.now();
        const lastResetTs = state.treasureChestLastReset;
        if (!lastResetTs) {
            return { treasureChestAttempts: 3, treasureChestLastReset: nowTs };
        }
        const nowUtcDate = new Date(nowTs);
        let lastRefreshMarkerUtcTs = Date.UTC(
            nowUtcDate.getUTCFullYear(), nowUtcDate.getUTCMonth(), nowUtcDate.getUTCDate(),
            RUNE_ATTEMPTS_REFRESH_HOUR_UTC, 0, 0, 0
        );
        if (nowTs < lastRefreshMarkerUtcTs) {
            lastRefreshMarkerUtcTs = Date.UTC(
                nowUtcDate.getUTCFullYear(), nowUtcDate.getUTCMonth(), nowUtcDate.getUTCDate() - 1,
                RUNE_ATTEMPTS_REFRESH_HOUR_UTC, 0, 0, 0
            );
        }
        if (lastResetTs < lastRefreshMarkerUtcTs) {
            return {
                treasureChestAttempts: 3,
                treasureChestLastReset: nowTs
            };
        }
        return {};
    }),
    useTreasureChestAttempt: () => set((state) => { // из КОД2
        if (state.treasureChestAttempts > 0) {
            return { treasureChestAttempts: state.treasureChestAttempts - 1 };
        }
        return {};
    }),
    initializeUserFromTelegram: (tgUserData) => { // из КОД2
        if (tgUserData && tgUserData.photo_url) {
            set({ userPhotoUrl: tgUserData.photo_url });
        } else {
            set(state => {
                if (state.userPhotoUrl !== null) {
                    return { userPhotoUrl: null };
                }
                return {};
            });
        }
    },

    // --- Функции сброса задач (из КОД1/КОД2) ---
    checkAndResetDailyTasks: () => set((state) => { // из КОД2, логика идентична КОД1
        const nowTs = Date.now();
        const lastResetTs = state.lastDailyReset;
        if (!lastResetTs) {
            const initialProgress = {};
            (ALL_TASK_DEFINITIONS[TASK_TYPES.DAILY] || []).forEach(task => {
                initialProgress[task.id] = { progress: 0, completed: false, claimed: false };
            });
            return {
                dailyTaskProgress: initialProgress, dailyTaskBarXp: 0, dailyBonusClaimed: false,
                lastDailyReset: nowTs, dailyLoginToday: false, killsToday: 0,
                levelsCompletedToday: 0, gearUpgradedToday: 0, chestsOpenedToday: 0,
            };
        }
        const nowUtcDate = new Date(nowTs);
        let lastRefreshMarkerUtcTs = Date.UTC(
            nowUtcDate.getUTCFullYear(), nowUtcDate.getUTCMonth(), nowUtcDate.getUTCDate(),
            DAILY_TASKS_REFRESH_HOUR_UTC, 0, 0, 0
        );
        if (nowTs < lastRefreshMarkerUtcTs) {
            const yesterdayUtcDate = new Date(nowTs - 24 * 60 * 60 * 1000);
            lastRefreshMarkerUtcTs = Date.UTC(
                yesterdayUtcDate.getUTCFullYear(), yesterdayUtcDate.getUTCMonth(), yesterdayUtcDate.getUTCDate(),
                DAILY_TASKS_REFRESH_HOUR_UTC, 0, 0, 0
            );
        }
        if (lastResetTs < lastRefreshMarkerUtcTs) {
            const initialProgress = {};
            (ALL_TASK_DEFINITIONS[TASK_TYPES.DAILY] || []).forEach(task => {
                initialProgress[task.id] = { progress: 0, completed: false, claimed: false };
            });
            return {
                dailyTaskProgress: initialProgress, dailyTaskBarXp: 0, dailyBonusClaimed: false,
                lastDailyReset: nowTs,
                dailyLoginToday: false, killsToday: 0, levelsCompletedToday: 0,
                gearUpgradedToday: 0, chestsOpenedToday: 0,
            };
        }
        return {};
    }),
    checkAndResetWeeklyTasks: () => set((state) => { // из КОД2, логика идентична КОД1
        const nowTs = Date.now();
        const lastResetTs = state.lastWeeklyReset;
        if (!lastResetTs) {
            const initialProgress = {};
             (ALL_TASK_DEFINITIONS[TASK_TYPES.WEEKLY] || []).forEach(task => {
                initialProgress[task.id] = { progress: 0, completed: false, claimed: false };
            });
            return {
                weeklyTaskProgress: initialProgress, weeklyTaskBarXp: 0, weeklyBonusClaimed: false,
                lastWeeklyReset: nowTs, weeklyLoginDays: 0, killsThisWeek: 0,
                levelsCompletedThisWeek: 0, gearUpgradedThisWeek: 0, chestsOpenedThisWeek: 0,
                lastSeenLoginDateForWeekly: null,
            };
        }
        const nowUtcDate = new Date(nowTs);
        const currentUtcDay = nowUtcDate.getUTCDay();
        let daysToLastRefreshDay = (currentUtcDay - WEEKLY_TASKS_REFRESH_DAY_UTC + 7) % 7;
        const lastRefreshDayDate = new Date(Date.UTC(
            nowUtcDate.getUTCFullYear(), nowUtcDate.getUTCMonth(), nowUtcDate.getUTCDate() - daysToLastRefreshDay
        ));
        let lastRefreshMarkerUtcTs = Date.UTC(
            lastRefreshDayDate.getUTCFullYear(), lastRefreshDayDate.getUTCMonth(), lastRefreshDayDate.getUTCDate(),
            WEEKLY_TASKS_REFRESH_HOUR_UTC, 0, 0, 0
        );
        if (currentUtcDay === WEEKLY_TASKS_REFRESH_DAY_UTC && nowTs < lastRefreshMarkerUtcTs) {
            const prevRefreshWeekDate = new Date(Date.UTC(
                nowUtcDate.getUTCFullYear(), nowUtcDate.getUTCMonth(), nowUtcDate.getUTCDate() - 7
            ));
             lastRefreshMarkerUtcTs = Date.UTC(
                prevRefreshWeekDate.getUTCFullYear(), prevRefreshWeekDate.getUTCMonth(), prevRefreshWeekDate.getUTCDate(),
                WEEKLY_TASKS_REFRESH_HOUR_UTC, 0, 0, 0
            );
        }
        if (lastResetTs < lastRefreshMarkerUtcTs) {
            const initialProgress = {};
            (ALL_TASK_DEFINITIONS[TASK_TYPES.WEEKLY] || []).forEach(task => {
                initialProgress[task.id] = { progress: 0, completed: false, claimed: false };
            });
            return {
                weeklyTaskProgress: initialProgress, weeklyTaskBarXp: 0, weeklyBonusClaimed: false,
                lastWeeklyReset: nowTs, weeklyLoginDays: 0, killsThisWeek: 0,
                levelsCompletedThisWeek: 0, gearUpgradedThisWeek: 0, chestsOpenedThisWeek: 0,
                lastSeenLoginDateForWeekly: null,
            };
        }
        return {};
    }),
    checkAndResetMonthlyTasks: () => set((state) => { // из КОД2, логика идентична КОД1
        const nowTs = Date.now();
        const lastResetTs = state.lastMonthlyReset;
        if (!lastResetTs) {
            const initialProgress = {};
            (ALL_TASK_DEFINITIONS[TASK_TYPES.MONTHLY] || []).forEach(task => {
                initialProgress[task.id] = { progress: 0, completed: false, claimed: false };
            });
            return {
                monthlyTaskProgress: initialProgress, monthlyTaskBarXp: 0, monthlyBonusClaimed: false,
                lastMonthlyReset: nowTs, monthlyLoginDays: 0, killsThisMonth: 0,
                levelsCompletedThisMonth: 0, gearUpgradedThisMonth: 0, chestsOpenedThisMonth: 0,
                lastSeenLoginDateForMonthly: null,
            };
        }
        const nowUtcDate = new Date(nowTs);
        let currentMonthRefreshMarkerUtcTs = Date.UTC(
            nowUtcDate.getUTCFullYear(), nowUtcDate.getUTCMonth(),
            MONTHLY_TASKS_REFRESH_DAY_OF_MONTH_UTC,
            MONTHLY_TASKS_REFRESH_HOUR_UTC, 0, 0, 0
        );
        let lastRefreshMarkerUtcTs;
        if (nowTs >= currentMonthRefreshMarkerUtcTs) {
            lastRefreshMarkerUtcTs = currentMonthRefreshMarkerUtcTs;
        } else {
            const prevMonthDate = new Date(Date.UTC(nowUtcDate.getUTCFullYear(), nowUtcDate.getUTCMonth() -1, 1));
            lastRefreshMarkerUtcTs = Date.UTC(
                prevMonthDate.getUTCFullYear(), prevMonthDate.getUTCMonth(),
                MONTHLY_TASKS_REFRESH_DAY_OF_MONTH_UTC,
                MONTHLY_TASKS_REFRESH_HOUR_UTC, 0, 0, 0
            );
        }
        if (lastResetTs < lastRefreshMarkerUtcTs) {
            const initialProgress = {};
             (ALL_TASK_DEFINITIONS[TASK_TYPES.MONTHLY] || []).forEach(task => {
                initialProgress[task.id] = { progress: 0, completed: false, claimed: false };
            });
            return {
                monthlyTaskProgress: initialProgress, monthlyTaskBarXp: 0, monthlyBonusClaimed: false,
                lastMonthlyReset: nowTs, monthlyLoginDays: 0, killsThisMonth: 0,
                levelsCompletedThisMonth: 0, gearUpgradedThisMonth: 0, chestsOpenedThisMonth: 0,
                lastSeenLoginDateForMonthly: null,
            };
        }
        return {};
    }),

    // trackTaskEvent (из КОД1 - расширенная версия для ShardPass и стандартных задач)
    trackTaskEvent: (eventType, amount = 1, eventDetails = {}) => {
        console.log(`[Tasks_TrackEvent_Store] Event: ${eventType}, Amount: ${amount}, Details:`, eventDetails);
        const state = get();
        let counterChanges = {};
        const now = new Date();
        const todayDateString = now.toISOString().split('T')[0];

        // 1. Обновляем периодические счетчики
        switch (eventType) {
            case 'login':
                if (!state.dailyLoginToday) counterChanges.dailyLoginToday = true;
                if (state.lastSeenLoginDateForWeekly !== todayDateString) {
                    counterChanges.weeklyLoginDays = (state.weeklyLoginDays || 0) + 1;
                    counterChanges.lastSeenLoginDateForWeekly = todayDateString;
                }
                if (state.lastSeenLoginDateForMonthly !== todayDateString) {
                    counterChanges.monthlyLoginDays = (state.monthlyLoginDays || 0) + 1;
                    counterChanges.lastSeenLoginDateForMonthly = todayDateString;
                }
                break;
            case 'kill_monster':
                counterChanges.killsToday = (state.killsToday || 0) + amount;
                counterChanges.killsThisWeek = (state.killsThisWeek || 0) + amount;
                counterChanges.killsThisMonth = (state.killsThisMonth || 0) + amount;
                break;
            case 'complete_level':
                counterChanges.levelsCompletedToday = (state.levelsCompletedToday || 0) + amount;
                counterChanges.levelsCompletedThisWeek = (state.levelsCompletedThisWeek || 0) + amount;
                counterChanges.levelsCompletedThisMonth = (state.levelsCompletedThisMonth || 0) + amount;
                break;
            case 'upgrade_gear':
                counterChanges.gearUpgradedToday = (state.gearUpgradedToday || 0) + amount;
                counterChanges.gearUpgradedThisWeek = (state.gearUpgradedThisWeek || 0) + amount;
                counterChanges.gearUpgradedThisMonth = (state.gearUpgradedThisMonth || 0) + amount;
                break;
            case 'open_chest':
                counterChanges.chestsOpenedToday = (state.chestsOpenedToday || 0) + amount;
                counterChanges.chestsOpenedThisWeek = (state.chestsOpenedThisWeek || 0) + amount;
                counterChanges.chestsOpenedThisMonth = (state.chestsOpenedThisMonth || 0) + amount;
                break;
            // earn_gold, earn_diamonds, earn_toncoin_shards, collect_item handled by their respective add functions
        }
        if (Object.keys(counterChanges).length > 0) {
            set(counterChanges);
        }

        const updatedState = get();

        // 2. Обновляем прогресс Daily/Weekly/Monthly задач (логика из КОД1)
        let newDailyProgress = { ...updatedState.dailyTaskProgress };
        let newWeeklyProgress = { ...updatedState.weeklyTaskProgress };
        let newMonthlyProgress = { ...updatedState.monthlyTaskProgress };
        let anyStandardTaskProgressChanged = false;

        const standardTaskProcessingLogic = (taskDef, progressObject, taskType) => {
            const taskState = progressObject[taskDef.id] || { progress: 0, completed: false, initialStatValue: 0 };
            if (taskState.completed) return false;
            let currentEventValueForTask = 0;
            let taskAffectedByThisEvent = false;

            if (taskDef.eventTracked === eventType ||
                (eventType === 'login' && (taskDef.eventTracked === 'dailyLoginToday' || taskDef.eventTracked === 'weeklyLoginDays' || taskDef.eventTracked === 'monthlyLoginDays')) ||
                (eventType === 'kill_monster' && (taskDef.eventTracked === 'killsToday' || taskDef.eventTracked === 'killsThisWeek' || taskDef.eventTracked === 'killsThisMonth' || taskDef.eventTracked === 'totalKills')) ||
                (eventType === 'complete_level' && (taskDef.eventTracked === 'levelsCompletedToday' || taskDef.eventTracked === 'levelsCompletedThisWeek' || taskDef.eventTracked === 'levelsCompletedThisMonth')) ||
                (eventType === 'upgrade_gear' && (taskDef.eventTracked === 'gearUpgradedToday' || taskDef.eventTracked === 'gearUpgradedThisWeek' || taskDef.eventTracked === 'gearUpgradedThisMonth')) ||
                (eventType === 'open_chest' && (taskDef.eventTracked === 'chestsOpenedToday' || taskDef.eventTracked === 'chestsOpenedThisWeek' || taskDef.eventTracked === 'chestsOpenedThisMonth'))
            ) {
                taskAffectedByThisEvent = true;
                if (updatedState.hasOwnProperty(taskDef.eventTracked)) {
                    currentEventValueForTask = updatedState[taskDef.eventTracked] || 0;
                     if (taskDef.eventTracked === 'dailyLoginToday') {
                         currentEventValueForTask = updatedState.dailyLoginToday ? 1 : 0;
                     }
                } else if (taskDef.eventTracked === eventType && taskDef.countIncrementally) {
                     currentEventValueForTask = (taskState.progress || 0) + amount;
                } else if (taskDef.eventTracked === eventType ) {
                     currentEventValueForTask = amount;
                }
            }

            if (taskAffectedByThisEvent) {
                currentEventValueForTask = Number(currentEventValueForTask) || 0;
                const newProgress = Math.min(currentEventValueForTask, taskDef.target);
                if (newProgress !== taskState.progress || (newProgress >= taskDef.target && !taskState.completed)) {
                    progressObject[taskDef.id] = {
                        ...taskState,
                        progress: newProgress,
                        completed: newProgress >= taskDef.target
                    };
                    if (progressObject[taskDef.id].completed && !taskState.completed) {
                        console.log(`[Tasks_Standard] ${taskType} task '${taskDef.id}' COMPLETED!`);
                    }
                    return true;
                }
            }
            return false;
        };

        [TASK_TYPES.DAILY, TASK_TYPES.WEEKLY, TASK_TYPES.MONTHLY].forEach(taskType => {
            const definitions = ALL_TASK_DEFINITIONS[taskType] || [];
            let progressMap;
            if (taskType === TASK_TYPES.DAILY) progressMap = newDailyProgress;
            else if (taskType === TASK_TYPES.WEEKLY) progressMap = newWeeklyProgress;
            else if (taskType === TASK_TYPES.MONTHLY) progressMap = newMonthlyProgress;
            else return;

            definitions.forEach(taskDef => {
                if (taskDef.eventTracked) {
                    if (standardTaskProcessingLogic(taskDef, progressMap, taskType)) {
                        anyStandardTaskProgressChanged = true;
                    }
                }
            });
        });
        if (anyStandardTaskProgressChanged) {
            set({
                dailyTaskProgress: newDailyProgress,
                weeklyTaskProgress: newWeeklyProgress,
                monthlyTaskProgress: newMonthlyProgress,
            });
        }

// 3. Обновляем прогресс ShardPass задач
// Используем updatedState, полученный после обновления счетчиков Daily/Weekly/Monthly
let newShardPassTasksProgress = JSON.parse(JSON.stringify(updatedState.shardPassTasksProgress));
let anyShardPassTaskProgressChanged = false;

Object.keys(shardPassTaskDefinitionsByWeek).forEach(weekKey => {
    // Убедимся, что newShardPassTasksProgress[weekKey] существует, если нет - инициализируем
    if (!newShardPassTasksProgress[weekKey]) {
        newShardPassTasksProgress[weekKey] = {};
    }

    shardPassTaskDefinitionsByWeek[weekKey].forEach(taskDef => {
        // Инициализация состояния задачи, если оно отсутствует, включая lastCountedLoginDate для задач на логин
        let spTaskState = newShardPassTasksProgress[weekKey][taskDef.id];
        if (!spTaskState) {
            spTaskState = {
                progress: 0,
                isClaimed: false,
                ...(taskDef.eventTracked === 'login' && { lastCountedLoginDate: null }) // Добавляем, если это задача на логин
            };
            newShardPassTasksProgress[weekKey][taskDef.id] = spTaskState;
        } else if (taskDef.eventTracked === 'login' && spTaskState.lastCountedLoginDate === undefined) {
            // Если состояние уже есть, но lastCountedLoginDate отсутствует для логин-задачи (например, из старого сохранения)
            spTaskState.lastCountedLoginDate = null;
        }


        if (spTaskState.isClaimed) return; // Пропускаем, если награда уже получена

        if (taskDef.eventTracked === eventType) { // Проверяем, соответствует ли событие отслеживаемому задачей
            let matchCondition = true;
            if (taskDef.condition) {
                matchCondition = Object.keys(taskDef.condition).every(key =>
                    eventDetails.hasOwnProperty(key) && eventDetails[key] === taskDef.condition[key]
                );
            }

            if (matchCondition) {
                if (taskDef.eventTracked === 'login') {
                    // <<< СПЕЦИАЛЬНАЯ ОБРАБОТКА ДЛЯ ЗАДАЧ SHARDPASS НА ЕЖЕДНЕВНЫЙ ВХОД >>>
                    if ((spTaskState.progress || 0) < taskDef.targetProgress) {
                        const todayDateString = new Date().toISOString().split('T')[0];
                        if (spTaskState.lastCountedLoginDate !== todayDateString) {
                            const newProgress = (spTaskState.progress || 0) + 1; // Увеличиваем на 1 за уникальный день
                            
                            newShardPassTasksProgress[weekKey][taskDef.id] = {
                                ...spTaskState,
                                progress: newProgress,
                                lastCountedLoginDate: todayDateString, // Обновляем дату последнего засчитанного входа
                            };
                            anyShardPassTaskProgressChanged = true;
                            console.log(`[Tasks_ShardPass_Login] Task '${taskDef.id}' (Week ${weekKey}) progress: ${newProgress}/${taskDef.targetProgress}`);
                        } else {
                            // console.log(`[Tasks_ShardPass_Login] Task '${taskDef.id}' (Week ${weekKey}) already counted login for ${todayDateString}`);
                        }
                    }
                } else {
                    // <<< ОБЩАЯ ОБРАБОТКА ДЛЯ ДРУГИХ ТИПОВ ЗАДАЧ SHARDPASS >>>
                    const currentProgress = spTaskState.progress || 0;
                    // 'amount' берется из аргументов trackTaskEvent
                    const newProgress = Math.min(currentProgress + amount, taskDef.targetProgress);
                    
                    // Обновляем, если прогресс изменился ИЛИ если достигнута цель (чтобы completed статус мог обновиться в UI)
                    if (newProgress !== currentProgress || (newProgress === taskDef.targetProgress && currentProgress < taskDef.targetProgress)) {
                        newShardPassTasksProgress[weekKey][taskDef.id] = {
                            ...spTaskState,
                            progress: newProgress,
                        };
                        // Если lastCountedLoginDate было в spTaskState для не-логин задачи (чего не должно быть), оно сохранится.
                        // Это можно исправить, если явно не копировать его для не-логин задач.
                        // Но по идее, оно там будет только если taskDef.eventTracked === 'login'
                        anyShardPassTaskProgressChanged = true;
                        console.log(`[Tasks_ShardPass] Task '${taskDef.id}' (Week ${weekKey}) progress: ${newProgress}/${taskDef.targetProgress}`);
                    }
                }
            }
        }
    });
});

        if (anyShardPassTaskProgressChanged) {
            set({ shardPassTasksProgress: newShardPassTasksProgress });
        }
        get().setHasClaimableRewardsIndicator(get().checkIfAnyTaskOrAchievementIsClaimable());  
    },

    claimTaskReward: (taskType, taskId) => { // из КОД2/КОД1
        const state = get();
        let progressObjectKey, taskBarXpKey, taskDefinitionsForType;
        let changesToSet = {};

        if (taskType === TASK_TYPES.DAILY) {
            progressObjectKey = 'dailyTaskProgress'; taskBarXpKey = 'dailyTaskBarXp';
            taskDefinitionsForType = ALL_TASK_DEFINITIONS[TASK_TYPES.DAILY];
        } else if (taskType === TASK_TYPES.WEEKLY) {
            progressObjectKey = 'weeklyTaskProgress'; taskBarXpKey = 'weeklyTaskBarXp';
            taskDefinitionsForType = ALL_TASK_DEFINITIONS[TASK_TYPES.WEEKLY];
        } else if (taskType === TASK_TYPES.MONTHLY) {
            progressObjectKey = 'monthlyTaskProgress'; taskBarXpKey = 'monthlyTaskBarXp';
            taskDefinitionsForType = ALL_TASK_DEFINITIONS[TASK_TYPES.MONTHLY];
        } else {
            console.error(`[Tasks] Unknown taskType for claim: ${taskType}`); return;
        }

        const currentTaskProgressMap = state[progressObjectKey];
        const taskState = currentTaskProgressMap ? currentTaskProgressMap[taskId] : null;
        const taskDef = taskDefinitionsForType ? taskDefinitionsForType.find(t => t.id === taskId) : null;

        if (taskState && taskDef && taskState.completed && !taskState.claimed) {
            console.log(`[Tasks] Claiming reward for ${taskType} task: ${taskId}`);
            if (taskDef.reward) {
                if (taskDef.reward.diamonds) get().addDiamonds(taskDef.reward.diamonds); // Uses modified addDiamonds
                if (taskDef.reward.gold) get().addGold(taskDef.reward.gold); // Uses modified addGold
                // Add item rewards if defined
            }
            const newProgressMap = { ...state[progressObjectKey], [taskId]: { ...taskState, claimed: true } };
            changesToSet[progressObjectKey] = newProgressMap;
            const newXp = (state[taskBarXpKey] || 0) + (taskDef.xp || 0);
            changesToSet[taskBarXpKey] = newXp;
            if (Object.keys(changesToSet).length > 0) set(changesToSet);
            get().checkAllAchievements();
            get().setHasClaimableRewardsIndicator(get().checkIfAnyTaskOrAchievementIsClaimable());
        }
    },
    claimBonusReward: (taskType) => { // из КОД2/КОД1
        const state = get();
        const bonusConfig = BONUS_REWARDS_CONFIG[taskType];
        if (!bonusConfig) { console.error(`[Tasks] No bonus config for taskType: ${taskType}`); return; }
        let taskBarXpKey, bonusClaimedKey;
        if (taskType === TASK_TYPES.DAILY) {
            taskBarXpKey = 'dailyTaskBarXp'; bonusClaimedKey = 'dailyBonusClaimed';
        } else if (taskType === TASK_TYPES.WEEKLY) {
            taskBarXpKey = 'weeklyTaskBarXp'; bonusClaimedKey = 'weeklyBonusClaimed';
        } else if (taskType === TASK_TYPES.MONTHLY) {
            taskBarXpKey = 'monthlyTaskBarXp'; bonusClaimedKey = 'monthlyBonusClaimed';
        } else {
            console.error(`[Tasks] Unknown taskType for bonus reward: ${taskType}`); return;
        }
        let changesToSet = {};
        if ((state[taskBarXpKey] || 0) >= bonusConfig.xpRequired && !state[bonusClaimedKey]) {
            console.log(`[Tasks] Claiming BONUS reward for ${taskType} tasks!`);
            const reward = bonusConfig.reward;
            if (reward.type === 'item_key' && reward.itemId) {
                // get().addItemToInventory(reward.itemId, reward.quantity || 1); // Uses modified addItemToInventory
                 console.warn(`[Tasks] Bonus item_key: ${reward.name || reward.itemId} x${reward.quantity || 1}. Implement properly`);
            } else if (reward.type === 'currency' && reward.currencyId) {
                if (reward.currencyId === 'diamonds') get().addDiamonds(reward.quantity); // Uses modified addDiamonds
                else if (reward.currencyId === 'gold') get().addGold(reward.quantity); // Uses modified addGold
                else if (reward.currencyId === 'toncoin_shards') get().addToncoinShards(reward.quantity); // Uses modified addToncoinShards
            }
            changesToSet[bonusClaimedKey] = true;
            set(changesToSet);
            get().checkAllAchievements();
            get().setHasClaimableRewardsIndicator(get().checkIfAnyTaskOrAchievementIsClaimable());
        }
    },

    // --- НОВЫЕ ACTIONS ДЛЯ SHARDPASS (из КОД1) ---
    purchaseShardPassPremium: () => {
        const currentPremiumStatus = get().isShardPassPremium;
        if (currentPremiumStatus) {
            console.log("ShardPass Premium is already active.");
            return { success: false, message: "Премиум уже активен." };
        }
        // Logic for currency deduction can be added here
        set({ isShardPassPremium: true });
        console.log("ShardPass Premium purchased and activated!");
        get().setHasClaimableRewardsIndicator(get().checkIfAnyTaskOrAchievementIsClaimable());
        return { success: true, message: "ShardPass Premium успешно активирован!" };
    },
    addShardPassXp: (xpAmount) => {
        if (xpAmount <= 0) return;
        set(state => {
            if (state.shardPassCurrentLevel >= state.shardPassMaxLevel) {
                return {};
            }
            let newXp = state.shardPassCurrentXp + xpAmount;
            let newLevel = state.shardPassCurrentLevel;
            let newChanges = {};
            while (newLevel < state.shardPassMaxLevel && newXp >= state.shardPassXpPerLevel) {
                newXp -= state.shardPassXpPerLevel;
                newLevel++;
                console.log(`ShardPass Level Up! New Level: ${newLevel}`);
            }
            if (newLevel >= state.shardPassMaxLevel) {
                newXp = Math.min(newXp, state.shardPassXpPerLevel);
                if (newLevel > state.shardPassMaxLevel) newLevel = state.shardPassMaxLevel;
            }
            newChanges.shardPassCurrentXp = newXp;
            newChanges.shardPassCurrentLevel = newLevel;
            return newChanges;
        });
        get().setHasClaimableRewardsIndicator(get().checkIfAnyTaskOrAchievementIsClaimable());
    },
    claimShardPassReward: (level, isPremiumTrack) => {
        const state = get();
        const rewardKey = `level_${level}_${isPremiumTrack ? 'premium' : 'free'}`;
        if (level > state.shardPassCurrentLevel) {
            return { success: false, message: "Уровень еще не достигнут." };
        }
        if (isPremiumTrack && !state.isShardPassPremium) {
            return { success: false, message: "Требуется ShardPass Premium." };
        }
        if (state.shardPassRewardsClaimed[rewardKey]) {
            return { success: false, message: "Награда уже получена." };
        }
        const levelDefinition = shardPassSeasonDefinitions.levels.find(l => l.level === level);
        if (!levelDefinition) {
            return { success: false, message: "Ошибка определения награды." };
        }
        const rewardToClaim = isPremiumTrack ? levelDefinition.premiumReward : levelDefinition.freeReward;
        if (!rewardToClaim) {
            return { success: false, message: "Награда не определена для этого уровня/типа." };
        }
        console.log(`[ShardPass] Claiming reward: ${rewardToClaim.name || 'Reward'} (Level ${level}, ${isPremiumTrack ? 'Premium' : 'Free'})`);
        if (rewardToClaim.type === 'gold') get().addGold(rewardToClaim.amount);
        else if (rewardToClaim.type === 'diamonds') get().addDiamonds(rewardToClaim.amount);
        else if (rewardToClaim.type === 'toncoin_shards') get().addToncoinShards(rewardToClaim.amount);
        else if (rewardToClaim.type === 'item' && rewardToClaim.itemId) get().addItemToInventory(rewardToClaim.itemId, rewardToClaim.amount || 1);
        else if (rewardToClaim.type === 'energy') get().addEnergy(rewardToClaim.amount);
        else {
            console.warn(`[ShardPass] Unknown reward type or missing data for ${rewardKey}:`, rewardToClaim);
        }
        set(prevState => ({
            shardPassRewardsClaimed: {
                ...prevState.shardPassRewardsClaimed,
                [rewardKey]: true,
            }
        }));
        get().setHasClaimableRewardsIndicator(get().checkIfAnyTaskOrAchievementIsClaimable());
        return { success: true, message: `Награда "${rewardToClaim.name || 'N/A'}" получена!`, reward: rewardToClaim };
    },
    claimAllShardPassRewards: () => {
        const state = get();
        const claimedRewardsList = [];
        let changesMade = false;
        shardPassSeasonDefinitions.levels.forEach(levelDef => {
            if (levelDef.level <= state.shardPassCurrentLevel) {
                const freeRewardKey = `level_${levelDef.level}_free`;
                if (levelDef.freeReward && !state.shardPassRewardsClaimed[freeRewardKey]) {
                    const result = get().claimShardPassReward(levelDef.level, false);
                    if (result.success && result.reward) {
                        claimedRewardsList.push(result.reward);
                        changesMade = true;
                    }
                }
                if (state.isShardPassPremium) {
                    const premiumRewardKey = `level_${levelDef.level}_premium`;
                    if (levelDef.premiumReward && !state.shardPassRewardsClaimed[premiumRewardKey]) {
                         const result = get().claimShardPassReward(levelDef.level, true);
                         if (result.success && result.reward) {
                             claimedRewardsList.push(result.reward);
                             changesMade = true;
                         }
                    }
                }
            }
        });
        if (!changesMade) {
            console.log("[ShardPass] No new rewards to claim with Claim All.");
        }
        get().setHasClaimableRewardsIndicator(get().checkIfAnyTaskOrAchievementIsClaimable());
        return claimedRewardsList;
    },
    claimShardPassTaskReward: (weekNumber, taskId) => {
        const state = get();
        const weekKey = String(weekNumber);
        const taskDef = shardPassTaskDefinitionsByWeek[weekKey]?.find(t => t.id === taskId);
        if (!taskDef) {
            return { success: false, message: "Задача не найдена." };
        }
        const taskProgressState = state.shardPassTasksProgress[weekKey]?.[taskId];
        if (!taskProgressState) {
            return { success: false, message: "Состояние задачи не найдено." };
        }
        if (taskDef.isPremium && !state.isShardPassPremium) {
            return { success: false, message: "Требуется ShardPass Premium для получения награды за это задание." };
        }
        if (taskProgressState.isClaimed) {
            return { success: false, message: "Награда за задание уже получена." };
        }
        if (taskProgressState.progress < taskDef.targetProgress) {
            return { success: false, message: "Задание еще не выполнено." };
        }
        get().addShardPassXp(taskDef.rewardXP);
        set(prevState => {
            const newTasksProgress = JSON.parse(JSON.stringify(prevState.shardPassTasksProgress));
            if (!newTasksProgress[weekKey]) newTasksProgress[weekKey] = {};
            newTasksProgress[weekKey][taskId] = {
                ...newTasksProgress[weekKey][taskId],
                isClaimed: true,
            };
            return { shardPassTasksProgress: newTasksProgress };
        });
        console.log(`[ShardPass_Tasks] Reward claimed for Task ID ${taskId} (Week ${weekKey}). XP: +${taskDef.rewardXP}`);
        get().setHasClaimableRewardsIndicator(get().checkIfAnyTaskOrAchievementIsClaimable());
        return { success: true, message: `Награда за задание "${taskDef.name}" получена! (+${taskDef.rewardXP} XP)` };
    },

    // checkIfAnyTaskOrAchievementIsClaimable (из КОД1 - расширенная версия)
    checkIfAnyTaskOrAchievementIsClaimable: () => {
        const state = get();
        const taskTypes = [TASK_TYPES.DAILY, TASK_TYPES.WEEKLY, TASK_TYPES.MONTHLY];
        for (const taskType of taskTypes) {
            const progressKey = `${taskType.toLowerCase()}TaskProgress`;
            const taskProgressMap = state[progressKey];
            if (taskProgressMap) {
                for (const taskId in taskProgressMap) {
                    if (taskProgressMap[taskId].completed && !taskProgressMap[taskId].claimed) return true;
                }
            }
            const bonusConfig = BONUS_REWARDS_CONFIG[taskType];
            if (bonusConfig) {
                const xpKey = `${taskType.toLowerCase()}TaskBarXp`;
                const claimedKey = `${taskType.toLowerCase()}BonusClaimed`;
                if ((state[xpKey] || 0) >= bonusConfig.xpRequired && !state[claimedKey]) return true;
            }
        }
        for (const achDef of achievementsData) {
            const status = state.achievementsStatus[achDef.id] || { completed: false, claimed: false };
            if (status.completed && !status.claimed) return true;
        }
        for (const levelDef of shardPassSeasonDefinitions.levels) {
            if (levelDef.level <= state.shardPassCurrentLevel) {
                const freeKey = `level_${levelDef.level}_free`;
                if (levelDef.freeReward && !state.shardPassRewardsClaimed[freeKey]) return true;
                if (state.isShardPassPremium) {
                    const premiumKey = `level_${levelDef.level}_premium`;
                    if (levelDef.premiumReward && !state.shardPassRewardsClaimed[premiumKey]) return true;
                }
            }
        }
        for (const weekKey in shardPassTaskDefinitionsByWeek) {
            const weekTasks = shardPassTaskDefinitionsByWeek[weekKey];
            const weekProgress = state.shardPassTasksProgress[weekKey];
            if (weekTasks && weekProgress) {
                for (const taskDef of weekTasks) {
                    const taskState = weekProgress[taskDef.id];
                    if (taskState && !taskState.isClaimed && (taskState.progress || 0) >= taskDef.targetProgress) {
                        if (taskDef.isPremium && !state.isShardPassPremium) {
                            continue;
                        }
                        return true;
                    }
                }
            }
        }
        return false;
    },

    resetGame: () => { // Объединенный из КОД1 и КОД2
        const defaultEquipped = getDefaultEquippedSet();
        const defaultStateForTasksOnReset = {
            dailyTaskProgress: {}, dailyTaskBarXp: 0, dailyBonusClaimed: false, lastDailyReset: null,
            dailyLoginToday: false, killsToday: 0, levelsCompletedToday: 0, gearUpgradedToday: 0, chestsOpenedToday: 0,
            lastSeenLoginDateForWeekly: null, lastSeenLoginDateForMonthly: null,
            weeklyTaskProgress: {}, weeklyTaskBarXp: 0, weeklyBonusClaimed: false, lastWeeklyReset: null,
            weeklyLoginDays: 0, killsThisWeek: 0, levelsCompletedThisWeek: 0, gearUpgradedThisWeek: 0, chestsOpenedThisWeek: 0,
            monthlyTaskProgress: {}, monthlyTaskBarXp: 0, monthlyBonusClaimed: false, lastMonthlyReset: null,
            monthlyLoginDays: 0, killsThisMonth: 0, levelsCompletedThisMonth: 0, gearUpgradedThisMonth: 0, chestsOpenedThisMonth: 0,
        };
        const defaultShardPassOnReset = getDefaultShardPassState(); // из КОД1
        set({
            gold: 100000, diamonds: 10000, toncoinShards: 0, toncoinBalance: 0,
            username: null, powerLevel: 0, userPhotoUrl: null,
            playerBaseStats: { ...DEFAULT_BASE_STATS },
            playerHp: DEFAULT_BASE_STATS.hp,
            playerRace: null,
            inventory: [],
            equipped: defaultEquipped,
            dailyShopPurchases: {}, achievementsStatus: {}, totalGoldCollected: 0, totalKills: 0,
            booleanFlags: {}, levelsCompleted: {}, achievementLevel: 1, achievementXp: 0,
            collectedArtifacts: new Set(), artifactLevels: {}, artifactChestPity: {},
            gearKeys: 0, totalArtifactChestsOpened: 0, gearChestPity: {}, totalGearChestsOpened: 0,
            dailyDeals: [], dailyDealsLastGenerated: null, lastOpenedChestInfo: null, lastChestRewards: null,
            activeDebuffs: [], isAffectedByWeakeningAura: false,
            energyMax: DEFAULT_MAX_ENERGY, energyCurrent: DEFAULT_MAX_ENERGY, lastEnergyRefillTimestamp: Date.now(),
            treasureChestAttempts: 3, treasureChestLastReset: null,
            completedZones: {}, currentChapterId: INITIAL_CHAPTER_ID,
            levelChestStates: {}, lastOpenedLevelChestRewards: null,
            hasClaimableRewardsIndicator: false,
            ...defaultStateForTasksOnReset,
            ...defaultShardPassOnReset, // Сброс ShardPass (из КОД1)
        });
        localStorage.removeItem(STORAGE_KEY);
        get().updatePowerLevel();
        get().checkAndRefreshDailyDeals();
        get().initializeLevelHp();
        get().checkAndResetDailyTasks();
        get().checkAndResetWeeklyTasks();
        get().checkAndResetMonthlyTasks();
        console.log("Game has been reset to default state including ShardPass.");
    },
}));

// ================== Сохранение в localStorage (ОБЪЕДИНЕНО КОД1 и КОД2) ==================
useGameStore.subscribe((state) => {
    const {
        gold, diamonds, toncoinShards, toncoinBalance, username, inventory, equipped, powerLevel,
        playerBaseStats, playerHp, playerRace,
        energyCurrent, energyMax, lastEnergyRefillTimestamp,
        dailyDeals, dailyDealsLastGenerated, dailyShopPurchases,
        achievementsStatus, totalGoldCollected, totalKills,
        booleanFlags, levelsCompleted,
        achievementLevel, achievementXp,
        collectedArtifacts, artifactLevels, artifactChestPity,
        gearKeys, totalArtifactChestsOpened, gearChestPity, totalGearChestsOpened,
        activeDebuffs, treasureChestAttempts, treasureChestLastReset,
        userPhotoUrl, currentChapterId, completedZones, isAffectedByWeakeningAura,
        levelChestStates,
        // Поля для задач
        dailyTaskProgress, dailyTaskBarXp, dailyBonusClaimed, lastDailyReset,
        dailyLoginToday, killsToday, levelsCompletedToday, gearUpgradedToday, chestsOpenedToday,
        lastSeenLoginDateForWeekly, lastSeenLoginDateForMonthly,
        weeklyTaskProgress, weeklyTaskBarXp, weeklyBonusClaimed, lastWeeklyReset,
        weeklyLoginDays, killsThisWeek, levelsCompletedThisWeek, gearUpgradedThisWeek, chestsOpenedThisWeek,
        monthlyTaskProgress, monthlyTaskBarXp, monthlyBonusClaimed, lastMonthlyReset,
        monthlyLoginDays, killsThisMonth, levelsCompletedThisMonth, gearUpgradedThisMonth, chestsOpenedThisMonth,
        // Поля ShardPass
        shardPassSeasonId, shardPassCurrentLevel, shardPassCurrentXp, shardPassXpPerLevel, shardPassMaxLevel,
        isShardPassPremium, shardPassRewardsClaimed, shardPassTasksProgress, shardPassSeasonStartDateUTC,
    } = state;

    const stateToSave = {
        gold, diamonds, toncoinShards, toncoinBalance, username, inventory, equipped, powerLevel,
        playerBaseStats, playerHp, playerRace,
        energyCurrent, energyMax, lastEnergyRefillTimestamp,
        dailyDeals, dailyDealsLastGenerated, dailyShopPurchases,
        achievementsStatus, totalGoldCollected, totalKills,
        booleanFlags, levelsCompleted,
        achievementLevel, achievementXp,
        collectedArtifacts: Array.from(collectedArtifacts),
        artifactLevels, artifactChestPity,
        gearKeys, totalArtifactChestsOpened, gearChestPity, totalGearChestsOpened,
        activeDebuffs, treasureChestAttempts, treasureChestLastReset,
        userPhotoUrl, currentChapterId, completedZones, isAffectedByWeakeningAura,
        levelChestStates,
        // Поля для задач
        dailyTaskProgress, dailyTaskBarXp, dailyBonusClaimed, lastDailyReset,
        dailyLoginToday, killsToday, levelsCompletedToday, gearUpgradedToday, chestsOpenedToday,
        lastSeenLoginDateForWeekly, lastSeenLoginDateForMonthly,
        weeklyTaskProgress, weeklyTaskBarXp, weeklyBonusClaimed, lastWeeklyReset,
        weeklyLoginDays, killsThisWeek, levelsCompletedThisWeek, gearUpgradedThisWeek, chestsOpenedThisWeek,
        monthlyTaskProgress, monthlyTaskBarXp, monthlyBonusClaimed, lastMonthlyReset,
        monthlyLoginDays, killsThisMonth, levelsCompletedThisMonth, gearUpgradedThisMonth, chestsOpenedThisMonth,
        // Поля ShardPass
        shardPassSeasonId, shardPassCurrentLevel, shardPassCurrentXp, shardPassXpPerLevel, shardPassMaxLevel,
        isShardPassPremium, shardPassRewardsClaimed, shardPassTasksProgress, shardPassSeasonStartDateUTC,
    };

    try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(stateToSave));
    } catch (error) {
        console.error("Ошибка сохранения состояния в localStorage:", error);
    }
});

// Interval for clearing expired debuffs (из КОД2)
setInterval(() => {
    useGameStore.getState().clearExpiredDebuffs();
}, 5000);

// Initial checks (Объединенные из КОД1 и КОД2)
setTimeout(() => {
    console.log("Performing initial checks for tasks, deals, energy, achievements, and ShardPass...");
    const store = useGameStore.getState();
    store.checkAndResetDailyTasks();
    store.checkAndResetWeeklyTasks();
    store.checkAndResetMonthlyTasks();
    // store.checkAndUnlockShardPassWeeklyTasks(); // Для логики анлока недель ShardPass (из КОД1, было закомментировано)
    store.checkAndRefreshDailyDeals();
    store.checkAndResetTreasureChestAttempts();
    store.refillEnergyOnLoad();
    store.checkAllAchievements();
    store.setHasClaimableRewardsIndicator(store.checkIfAnyTaskOrAchievementIsClaimable());
}, 100);

export default useGameStore;